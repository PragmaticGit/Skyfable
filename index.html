<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SkyFable - Weather-Based Game Discovery</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body { 
            font-family: 'Quicksand', sans-serif; 
        }
        .pulse-animation {
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        .loading-spin {
            animation: spin 2s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #kofiwidget2-container {
            position: fixed !important;
            right: 20px !important;
            left: auto !important;
            bottom: 20px !important;
            z-index: 9999 !important;
        }
        #kofi-float-btn {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 9999;
        }
        body.clear-ui .rounded-lg, body.clear-ui .shadow-lg, body.clear-ui .shadow-2xl {
            box-shadow: 0 0 0 2px #fffbe0, 0 4px 32px 0 rgba(130,120,255,0.10);
            border: 1.5px solid #fffbe0 !important;
        }
        body.cloudy-ui .rounded-lg, body.cloudy-ui .shadow-lg, body.cloudy-ui .shadow-2xl {
            filter: blur(0.5px) contrast(0.97) brightness(0.98) saturate(0.93);
            box-shadow: none !important;
            border: none !important;
        }
        body.cloudy-ui .weather-headline-rain, body.cloudy-ui .weather-headline-sunny, body.cloudy-ui .weather-headline-snow, body.cloudy-ui h1, body.cloudy-ui h2 {
            animation: cloudy-wind 4.5s ease-in-out infinite alternate;
        }
        @keyframes cloudy-wind {
            0% { transform: translateX(-2px); }
            100% { transform: translateX(4px); }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div id="weather-particles-root" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:0;pointer-events:none;"></div>
    <div id="weather-overlay-root" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1;pointer-events:none;"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // WeatherParticles: CSS/Canvas-based background particles
        const WeatherParticles = ({ weatherType }) => {
          const canvasRef = useRef(null);
          const animationRef = useRef(null);
          const [dpr, setDpr] = useState(window.devicePixelRatio || 1);

          // Particle configs for each weather
          const configs = {
            rain: {
              count: 60,
              color: 'rgba(255,255,255,0.18)',
              speed: [2, 4],
              length: [16, 32],
              width: 1.2
            },
            snow: {
              count: 40,
              color: 'rgba(255,255,255,0.13)',
              speed: [0.5, 1.2],
              size: [2, 5]
            },
            sunny: {
              count: 18,
              color: 'rgba(255, 200, 80, 0.18)',
              speed: [0.3, 0.7],
              size: [2, 4]
            },
            cloudy: {
              shadowCount: 4, // Number of cloud shadows
              shadowColor: 'rgba(60,60,80,0.13)',
              shadowSize: [220, 420],
              shadowSpeed: [0.04, 0.09],
              waveSpeed: 0.12
            },
            fog: {
              count: 0 // Placeholder for future
            },
            clear: {
              moteCount: 18, // Dust motes
              moteColor: 'rgba(255,255,220,0.13)',
              moteSize: [1.2, 2.8],
              moteSpeed: [0.02, 0.07],
              starCount: 6, // Sparse twinkles
              starColor: 'rgba(255,255,255,0.7)',
              starSize: [0.7, 1.5]
            }
          };

          // Generate initial particles
          const createParticles = (type, w, h) => {
            const arr = [];
            if (type === 'rain') {
              for (let i = 0; i < configs.rain.count; i++) {
                arr.push({
                  x: Math.random() * w,
                  y: Math.random() * h,
                  l: configs.rain.length[0] + Math.random() * (configs.rain.length[1] - configs.rain.length[0]),
                  speed: configs.rain.speed[0] + Math.random() * (configs.rain.speed[1] - configs.rain.speed[0])
                });
              }
            } else if (type === 'snow') {
              for (let i = 0; i < configs.snow.count; i++) {
                arr.push({
                  x: Math.random() * w,
                  y: Math.random() * h,
                  r: configs.snow.size[0] + Math.random() * (configs.snow.size[1] - configs.snow.size[0]),
                  speed: configs.snow.speed[0] + Math.random() * (configs.snow.speed[1] - configs.snow.speed[0]),
                  drift: (Math.random() - 0.5) * 0.5
                });
              }
            } else if (type === 'sunny') {
              for (let i = 0; i < configs.sunny.count; i++) {
                arr.push({
                  x: Math.random() * w,
                  y: Math.random() * h,
                  r: configs.sunny.size[0] + Math.random() * (configs.sunny.size[1] - configs.sunny.size[0]),
                  speed: configs.sunny.speed[0] + Math.random() * (configs.sunny.speed[1] - configs.sunny.speed[0]),
                  alpha: 0.7 + Math.random() * 0.3
                });
              }
            } else if (type === 'cloudy') {
              // Cloud shadows
              for (let i = 0; i < configs.cloudy.shadowCount; i++) {
                arr.push({
                  x: Math.random() * w,
                  y: h * 0.2 + Math.random() * (h * 0.5),
                  r: configs.cloudy.shadowSize[0] + Math.random() * (configs.cloudy.shadowSize[1] - configs.cloudy.shadowSize[0]),
                  speed: configs.cloudy.shadowSpeed[0] + Math.random() * (configs.cloudy.shadowSpeed[1] - configs.cloudy.shadowSpeed[0]),
                  opacity: 0.13 + Math.random() * 0.09
                });
              }
            } else if (type === 'clear') {
              // Dust motes
              for (let i = 0; i < configs.clear.moteCount; i++) {
                arr.push({
                  x: Math.random() * w,
                  y: Math.random() * h,
                  r: configs.clear.moteSize[0] + Math.random() * (configs.clear.moteSize[1] - configs.clear.moteSize[0]),
                  speedX: (Math.random() - 0.5) * configs.clear.moteSpeed[1],
                  speedY: (Math.random() - 0.5) * configs.clear.moteSpeed[1],
                  alpha: 0.10 + Math.random() * 0.10
                });
              }
              // Sparse twinkling stars
              for (let i = 0; i < configs.clear.starCount; i++) {
                arr.push({
                  star: true,
                  x: Math.random() * w,
                  y: Math.random() * h * 0.7,
                  r: configs.clear.starSize[0] + Math.random() * (configs.clear.starSize[1] - configs.clear.starSize[0]),
                  twinklePhase: Math.random() * Math.PI * 2
                });
              }
            }
            return arr;
          };

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let width = window.innerWidth;
            let height = window.innerHeight;
            let type = weatherType;
            if (!configs[type] || (type !== 'cloudy' && type !== 'clear' && configs[type].count === 0)) type = 'clear';
            let particles = createParticles(type, width, height);

            // Set canvas size
            const setCanvasSize = () => {
              setDpr(window.devicePixelRatio || 1);
              width = window.innerWidth;
              height = window.innerHeight;
              canvas.width = width * dpr;
              canvas.height = height * dpr;
              canvas.style.width = width + 'px';
              canvas.style.height = height + 'px';
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.scale(dpr, dpr);
              particles = createParticles(type, width, height);
            };
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);

            // Animation loop
            const animate = () => {
              ctx.clearRect(0, 0, width, height);
              if (type === 'rain') {
                ctx.strokeStyle = configs.rain.color;
                ctx.lineWidth = configs.rain.width;
                for (let p of particles) {
                  ctx.beginPath();
                  ctx.moveTo(p.x, p.y);
                  ctx.lineTo(p.x, p.y + p.l);
                  ctx.stroke();
                  p.y += p.speed;
                  if (p.y > height) {
                    p.x = Math.random() * width;
                    p.y = -p.l;
                  }
                }
              } else if (type === 'snow') {
                ctx.fillStyle = configs.snow.color;
                for (let p of particles) {
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);
                  ctx.fill();
                  p.y += p.speed;
                  p.x += p.drift;
                  if (p.y > height) {
                    p.x = Math.random() * width;
                    p.y = -p.r;
                  }
                  if (p.x < 0) p.x = width;
                  if (p.x > width) p.x = 0;
                }
              } else if (type === 'sunny') {
                for (let p of particles) {
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);
                  ctx.fillStyle = `rgba(255, 200, 80, ${p.alpha})`;
                  ctx.shadowColor = '#FFD580';
                  ctx.shadowBlur = 8;
                  ctx.fill();
                  ctx.shadowBlur = 0;
                  p.y -= p.speed * 0.5;
                  if (p.y < -p.r) {
                    p.x = Math.random() * width;
                    p.y = height + p.r;
                  }
                }
              } else if (type === 'cloudy') {
                // Draw drifting cloud shadows
                for (let p of particles) {
                  ctx.save();
                  ctx.globalAlpha = p.opacity;
                  ctx.beginPath();
                  ctx.ellipse(p.x, p.y, p.r, p.r * 0.45, 0, 0, 2 * Math.PI);
                  ctx.fillStyle = configs.cloudy.shadowColor;
                  ctx.filter = 'blur(8px)';
                  ctx.fill();
                  ctx.filter = 'none';
                  ctx.restore();
                  p.x += p.speed;
                  if (p.x - p.r > width) {
                    p.x = -p.r;
                    p.y = height * 0.2 + Math.random() * (height * 0.5);
                  }
                }
                // Animated wavy gray overlay
                ctx.save();
                ctx.globalAlpha = 0.13;
                const waveY = (t) => Math.sin(t * 0.0002) * 12;
                for (let i = 0; i < 3; i++) {
                  ctx.beginPath();
                  let t = Date.now() + i * 1000;
                  ctx.moveTo(0, height * 0.7 + waveY(t));
                  for (let x = 0; x <= width; x += 32) {
                    ctx.lineTo(x, height * 0.7 + waveY(t + x * 2 + i * 500));
                  }
                  ctx.lineTo(width, height);
                  ctx.lineTo(0, height);
                  ctx.closePath();
                  ctx.fillStyle = '#888';
                  ctx.fill();
                }
                ctx.restore();
              } else if (type === 'clear') {
                // Soft gradient breathing background (drawn as a pulsing overlay)
                const breath = 0.93 + 0.07 * Math.sin(Date.now() * 0.00025);
                ctx.save();
                const grad = ctx.createLinearGradient(0, 0, 0, height);
                grad.addColorStop(0, `rgba(255,255,255,${0.10 * breath})`);
                grad.addColorStop(1, `rgba(255,255,220,${0.13 * breath})`);
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, width, height);
                ctx.restore();
                // Dust motes
                for (let p of particles) {
                  if (p.star) continue;
                  ctx.save();
                  ctx.globalAlpha = p.alpha;
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);
                  ctx.fillStyle = configs.clear.moteColor;
                  ctx.shadowColor = '#fffbe0';
                  ctx.shadowBlur = 4;
                  ctx.fill();
                  ctx.shadowBlur = 0;
                  ctx.restore();
                  // Gentle floating
                  p.x += p.speedX;
                  p.y += p.speedY;
                  if (p.x < 0) p.x = width;
                  if (p.x > width) p.x = 0;
                  if (p.y < 0) p.y = height;
                  if (p.y > height) p.y = 0;
                }
                // Sparse twinkling stars
                for (let p of particles) {
                  if (!p.star) continue;
                  const twinkle = 0.7 + 0.3 * Math.sin(Date.now() * 0.0007 + p.twinklePhase);
                  ctx.save();
                  ctx.globalAlpha = twinkle * 0.7;
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, p.r * twinkle, 0, 2 * Math.PI);
                  ctx.fillStyle = configs.clear.starColor;
                  ctx.shadowColor = '#fff';
                  ctx.shadowBlur = 8 * twinkle;
                  ctx.fill();
                  ctx.shadowBlur = 0;
                  ctx.restore();
                }
              }
              animationRef.current = requestAnimationFrame(animate);
            };
            animate();

            return () => {
              window.removeEventListener('resize', setCanvasSize);
              cancelAnimationFrame(animationRef.current);
            };
          }, [weatherType, dpr]);

          return (
            <canvas ref={canvasRef} style={{position:'fixed',top:0,left:0,width:'100vw',height:'100vh',zIndex:0,pointerEvents:'none'}} />
          );
        };

        // WeatherOverlay: ambient color gradient overlay
        const WeatherOverlay = ({ weatherType }) => {
          // Define gradients for each weather type
          const gradients = {
            rain: 'linear-gradient(120deg, rgba(80,90,180,0.18) 0%, rgba(120,180,255,0.22) 100%)',
            snow: 'linear-gradient(120deg, rgba(200,220,255,0.13) 0%, rgba(180,180,255,0.18) 100%)',
            sunny: 'linear-gradient(120deg, rgba(255,200,100,0.13) 0%, rgba(255,240,180,0.12) 100%)',
            cloudy: 'linear-gradient(120deg, rgba(120,120,180,0.13) 0%, rgba(180,180,200,0.13) 100%)',
            fog: 'linear-gradient(120deg, rgba(180,180,200,0.10) 0%, rgba(200,200,220,0.13) 100%)',
            clear: 'linear-gradient(120deg, rgba(130,120,255,0.08) 0%, rgba(255,255,255,0.08) 100%)'
          };
          const style = {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100vw',
            height: '100vh',
            zIndex: 1,
            pointerEvents: 'none',
            transition: 'background 0.8s cubic-bezier(.4,0,.2,1)',
            background: gradients[weatherType] || gradients.clear
          };
          return <div style={style} />;
        };

        // WeatherHeadline: main headline with minimal weather effect
        const WeatherHeadline = ({ weatherType, children }) => {
          // Rain: subtle drip on descenders; Sunny: gentle glow; Snow: sparkles
          if (weatherType === 'rain') {
            return (
              <span className="weather-headline-rain" style={{position:'relative',display:'inline-block'}}>
                {children}
                <style>{`
                  .weather-headline-rain .drip {
                    position: absolute;
                    width: 3px;
                    height: 12px;
                    background: linear-gradient(to bottom, #FFF8CC 60%, rgba(255,255,255,0));
                    border-radius: 2px;
                    left: 0.32em;
                    top: 1.1em;
                    opacity: 0.10;
                    animation: drip-fall 2.8s infinite linear;
                  }
                  @keyframes drip-fall {
                    0% { opacity: 0.10; transform: translateY(0); }
                    80% { opacity: 0.10; }
                    100% { opacity: 0; transform: translateY(12px); }
                  }
                `}</style>
                <span className="drip" />
              </span>
            );
          } else if (weatherType === 'sunny') {
            return (
              <span className="weather-headline-sunny" style={{position:'relative',display:'inline-block',textShadow:'0 0 4px #ffe9a0, 0 0 1px #fff099'}}>
                {children}
                <style>{`
                  .weather-headline-sunny {
                    animation: sunny-glow 3.5s infinite alternate;
                  }
                  @keyframes sunny-glow {
                    0% { text-shadow: 0 0 2px #ffe9a0, 0 0 1px #fff099; }
                    100% { text-shadow: 0 0 8px #ffe9a0, 0 0 3px #fff099; }
                  }
                `}</style>
              </span>
            );
          } else if (weatherType === 'snow') {
            return (
              <span className="weather-headline-snow" style={{position:'relative',display:'inline-block'}}>
                {children}
                <span className="sparkle" style={{position:'absolute',left:'0.5em',top:'-0.3em',fontSize:'0.5em',color:'#fff',opacity:0.4,animation:'sparkle-fade 3.2s infinite alternate'}}>*</span>
                <style>{`
                  @keyframes sparkle-fade {
                    0% { opacity: 0.4; transform: scale(1) rotate(0deg); }
                    50% { opacity: 0.7; transform: scale(1.1) rotate(10deg); }
                    100% { opacity: 0.4; transform: scale(1) rotate(0deg); }
                  }
                `}</style>
              </span>
            );
          } else {
            return <span>{children}</span>;
          }
        };

        const SkyFable = () => {
          const [currentScreen, setCurrentScreen] = useState('landing');
          const [weather, setWeather] = useState(null);
          const [location, setLocation] = useState(null);
          const [gameRecommendation, setGameRecommendation] = useState(null);
          const [loadingProgress, setLoadingProgress] = useState(0);
          const [lastGameTitle, setLastGameTitle] = useState(null);
          const [locationError, setLocationError] = useState(false);
          const [gameCache, setGameCache] = useState({}); // Cache for loaded game databases
          const [weatherType, setWeatherType] = useState('clear');

          // Fun status messages for loading
          const loadingStatuses = [
            "Consulting the weather spirits...",
            "Rolling the dice of fate...",
            "Matching your mood with the perfect game...",
            "Summoning pixelated adventures...",
            "Almost there, preparing your quest..."
          ];

          const getWeatherType = (condition, temp = 20) => {
            const lowerCondition = condition.toLowerCase();
            console.log('Weather condition received:', condition, 'Temperature:', temp);
            
            let weatherType = 'clear';
            
            if (lowerCondition.includes('rain') || lowerCondition.includes('drizzle') || 
                lowerCondition.includes('shower') || lowerCondition.includes('storm')) {
              weatherType = 'rain';
            } else if (lowerCondition.includes('snow') || lowerCondition.includes('blizzard')) {
              weatherType = 'snow';
            } else if (lowerCondition.includes('cloud') || lowerCondition.includes('overcast')) {
              weatherType = 'cloudy';
            } else if (lowerCondition.includes('sun') || lowerCondition.includes('clear') || (temp > 25)) {
              weatherType = 'sunny';
            } else if (lowerCondition.includes('fog') || lowerCondition.includes('mist')) {
              weatherType = 'cloudy';
            }
            
            console.log('Determined weather type:', weatherType);
            return weatherType;
          };

          // Load games from JSON file for specific weather type
          const loadGamesForWeather = async (weatherType) => {
            // Check cache first
            if (gameCache[weatherType]) {
              console.log(`Using cached games for ${weatherType}`);
              return gameCache[weatherType];
            }

            try {
              console.log(`Loading games for weather type: ${weatherType}`);
              const response = await fetch(`${weatherType}-games.json`);
              
              if (!response.ok) {
                throw new Error(`Failed to load ${weatherType} games`);
              }
              
              const data = await response.json();
              console.log(`Loaded ${data.games.length} games for ${weatherType}`);
              
              // Cache the result
              setGameCache(prev => ({
                ...prev,
                [weatherType]: data.games
              }));
              
              return data.games;
            } catch (error) {
              console.error(`Error loading ${weatherType} games:`, error);
              // Return fallback games if JSON loading fails
              return getFallbackGames(weatherType);
            }
          };

          // Fallback games in case JSON files fail to load
          const getFallbackGames = (weatherType) => {
            const fallbackGames = {
              rain: [{
                id: "firewatch_fallback",
                title: "Firewatch",
                tags: ["Single-player", "Atmospheric", "Story-Rich"],
                description: "A first-person mystery in the Wyoming wilderness. Perfect for rainy day contemplation.",
                steamUrl: "https://store.steampowered.com/app/383870/Firewatch/",
                gameImage: "https://cdn.akamai.steamstatic.com/steam/apps/383870/header.jpg",
                weatherScore: 9,
                rating: 79
              }],
              sunny: [{
                id: "no_mans_sky_fallback",
                title: "No Man's Sky",
                tags: ["Space", "Exploration", "Colorful"],
                description: "Explore vibrant alien worlds under exotic skies. Perfect for sunny day adventures.",
                steamUrl: "https://store.steampowered.com/app/275850/No_Mans_Sky/",
                gameImage: "https://cdn.akamai.steamstatic.com/steam/apps/275850/header.jpg",
                weatherScore: 9,
                rating: 71
              }],
              cloudy: [{
                id: "control_fallback",
                title: "Control",
                tags: ["Supernatural", "Mysterious", "Paranormal"],
                description: "Navigate supernatural phenomena in a mysterious building. Perfect for cloudy contemplation.",
                steamUrl: "https://store.steampowered.com/app/870780/Control_Ultimate_Edition/",
                gameImage: "https://cdn.akamai.steamstatic.com/steam/apps/870780/header.jpg",
                weatherScore: 9,
                rating: 82
              }],
              snow: [{
                id: "long_dark_fallback",
                title: "The Long Dark",
                tags: ["Survival", "Winter", "Atmospheric"],
                description: "Ultimate winter survival experience. Perfect for appreciating your warm shelter.",
                steamUrl: "https://store.steampowered.com/app/305620/The_Long_Dark/",
                gameImage: "https://cdn.akamai.steamstatic.com/steam/apps/305620/header.jpg",
                weatherScore: 10,
                rating: 78
              }],
              clear: [{
                id: "journey_fallback",
                title: "Journey",
                tags: ["Transcendent", "Beautiful", "Meditative"],
                description: "A wordless adventure that captures the wonder of perfect weather.",
                steamUrl: "https://store.steampowered.com/app/638230/Journey/",
                gameImage: "https://cdn.akamai.steamstatic.com/steam/apps/638230/header.jpg",
                weatherScore: 10,
                rating: 92
              }]
            };
            
            return fallbackGames[weatherType] || fallbackGames.clear;
          };

          const selectRandomGame = async (weatherType, avoidTitle = null) => {
            const availableGames = await loadGamesForWeather(weatherType);
            console.log('Available games for', weatherType, ':', availableGames.map(g => g.title));
            
            if (availableGames.length <= 1 || !avoidTitle) {
              const randomGame = availableGames[Math.floor(Math.random() * availableGames.length)];
              console.log('Selected game:', randomGame.title);
              return randomGame;
            }
            
            const filteredGames = availableGames.filter(game => game.title !== avoidTitle);
            const gamesToChooseFrom = filteredGames.length > 0 ? filteredGames : availableGames;
            
            const randomGame = gamesToChooseFrom[Math.floor(Math.random() * gamesToChooseFrom.length)];
            console.log('Selected game (avoiding duplicates):', randomGame.title);
            return randomGame;
          };

          const fetchWeather = async (lat, lon) => {
            try {
              const response = await fetch(`https://wttr.in/${lat},${lon}?format=j1`);
              
              if (!response.ok) {
                throw new Error('Weather fetch failed');
              }
              
              const data = await response.json();
              const current = data.current_condition[0];
              const location = data.nearest_area[0];
              
              return {
                weather: [{ 
                  main: current.weatherDesc[0].value,
                  description: current.weatherDesc[0].value.toLowerCase()
                }],
                name: location.areaName[0].value,
                main: { 
                  temp: parseInt(current.temp_C)
                }
              };
            } catch (error) {
              console.error('Weather API failed, using fallback:', error);
              return {
                weather: [{ main: 'Rain', description: 'rainy evening' }],
                name: 'Stavanger',
                main: { temp: 18 }
              };
            }
          };

          const getLocation = () => {
            return new Promise((resolve, reject) => {
              if (!navigator.geolocation) {
                console.log('Geolocation not supported, using fallback');
                resolve({ lat: 59.9139, lon: 10.7522 });
                return;
              }

              navigator.geolocation.getCurrentPosition(
                (position) => {
                  console.log('Location permission granted');
                  setLocationError(false);
                  resolve({
                    lat: position.coords.latitude,
                    lon: position.coords.longitude
                  });
                },
                (error) => {
                  console.error('Geolocation error:', error);
                  if (error.code === error.PERMISSION_DENIED) {
                    console.log('Location permission denied by user');
                    setLocationError(true);
                    reject(new Error('Location permission denied'));
                  } else {
                    console.log('Location error, using fallback');
                    resolve({ lat: 59.9139, lon: 10.7522 });
                  }
                }
              );
            });
          };

          const handleForecastClick = async () => {
            setCurrentScreen('loading');
            setLoadingProgress(0);
            setLocationError(false);

            const progressInterval = setInterval(() => {
              setLoadingProgress(prev => {
                if (prev >= 90) {
                  clearInterval(progressInterval);
                  return 90;
                }
                return prev + Math.random() * 25;
              });
            }, 150);

            try {
              const userLocation = await getLocation();
              setLocation(userLocation);

              const weatherData = await fetchWeather(userLocation.lat, userLocation.lon);
              setWeather(weatherData);
              console.log('=== WEATHER DATA ===');
              console.log('Raw weather:', weatherData);

              const weatherType = getWeatherType(weatherData.weather[0].main, weatherData.main.temp);
              console.log('=== GAME SELECTION ===');
              const randomGame = await selectRandomGame(weatherType);
              console.log('Final selected game:', randomGame);
              
              setGameRecommendation(randomGame);
              setLastGameTitle(randomGame.title);

              setTimeout(() => {
                setLoadingProgress(100);
                setTimeout(() => {
                  setCurrentScreen('result');
                }, 300);
              }, 1200);

            } catch (error) {
              console.error('Error fetching data:', error);
              clearInterval(progressInterval);
              
              if (error.message === 'Location permission denied') {
                setTimeout(() => {
                  setCurrentScreen('location-error');
                }, 1000);
              } else {
                const allWeatherTypes = ['rain', 'sunny', 'cloudy', 'snow', 'clear'];
                const randomWeatherType = allWeatherTypes[Math.floor(Math.random() * allWeatherTypes.length)];
                console.log('Using fallback weather type:', randomWeatherType);
                
                const fallbackGame = await selectRandomGame(randomWeatherType);
                setGameRecommendation(fallbackGame);
                setLastGameTitle(fallbackGame.title);
                
                setWeather({
                  weather: [{ main: 'Unknown', description: 'weather unavailable' }],
                  name: 'Your Location',
                  main: { temp: 20 }
                });
                
                setTimeout(() => {
                  setLoadingProgress(100);
                  setTimeout(() => {
                    setCurrentScreen('result');
                  }, 300);
                }, 1200);
              }
            }
          };

          const handleRollAgain = async () => {
            setCurrentScreen('loading');
            setLoadingProgress(0);

            const progressInterval = setInterval(() => {
              setLoadingProgress(prev => {
                if (prev >= 90) {
                  clearInterval(progressInterval);
                  return 90;
                }
                return prev + Math.random() * 20;
              });
            }, 200);

            setTimeout(async () => {
              if (weather) {
                const weatherType = getWeatherType(weather.weather[0].main, weather.main.temp);
                const randomGame = await selectRandomGame(weatherType, lastGameTitle);
                setGameRecommendation(randomGame);
                setLastGameTitle(randomGame.title);
              }
              
              setLoadingProgress(100);
              setTimeout(() => {
                setCurrentScreen('result');
              }, 300);
            }, 1200);
          };

          useEffect(() => {
            const loadInitialWeather = async () => {
              try {
                const userLocation = await getLocation();
                setLocation(userLocation);
                const weatherData = await fetchWeather(userLocation.lat, userLocation.lon);
                setWeather(weatherData);
              } catch (error) {
                console.error('Failed to load initial weather:', error);
              }
            };

            loadInitialWeather();
          }, []);

          // Update weatherType when weather changes
          useEffect(() => {
            if (weather && weather.weather && weather.main) {
              setWeatherType(getWeatherType(weather.weather[0].main, weather.main.temp));
            }
          }, [weather]);

          // Render particles and overlay globally
          useEffect(() => {
            const root = document.getElementById('weather-particles-root');
            if (root) ReactDOM.render(<WeatherParticles weatherType={weatherType} />, root);
            const overlayRoot = document.getElementById('weather-overlay-root');
            if (overlayRoot) ReactDOM.render(<WeatherOverlay weatherType={weatherType} />, overlayRoot);
            return () => {
              if (root) ReactDOM.unmountComponentAtNode(root);
              if (overlayRoot) ReactDOM.unmountComponentAtNode(overlayRoot);
            };
          }, [weatherType]);

          // Add crisp border/shadow to main UI cards/buttons for clear weather
          // and softening filter for cloudy weather
          // (inject a class on body based on weatherType)
          useEffect(() => {
            const body = document.body;
            body.classList.remove('clear-ui', 'cloudy-ui');
            if (weatherType === 'clear') {
              body.classList.add('clear-ui');
            } else if (weatherType === 'cloudy') {
              body.classList.add('cloudy-ui');
            }
          }, [weatherType]);

          // In renderLanding, add a button to manually cycle weatherType
          const availableWeatherTypes = ['rain', 'sunny', 'cloudy', 'snow', 'clear'];
          const [manualWeather, setManualWeather] = useState(null);
          const effectiveWeatherType = manualWeather || weatherType;

          // When manually cycling weather, also update the game recommendation and weather effects
          const handleCycleWeather = async () => {
            const currentIdx = availableWeatherTypes.indexOf(effectiveWeatherType);
            const nextIdx = (currentIdx + 1) % availableWeatherTypes.length;
            const newWeather = availableWeatherTypes[nextIdx];
            setManualWeather(newWeather);
            // Pick a random game for the new weather
            const randomGame = await selectRandomGame(newWeather);
            setGameRecommendation(randomGame);
            setLastGameTitle(randomGame.title);
            // Set weather state to match the manual weather for all effects
            setWeather({
              weather: [{ main: newWeather, description: newWeather }],
              name: 'Manual',
              main: { temp: 20 }
            });
          };

          const renderLanding = () => (
            <div className="min-h-screen relative overflow-hidden" style={{backgroundColor: '#837EB4'}}>
              <nav className="flex justify-between items-center px-4 sm:px-8 py-6 relative z-10" style={{backgroundColor: '#504B81'}}>
                <div 
                  className="text-white text-xl sm:text-2xl font-bold cursor-pointer hover:opacity-80 transition-opacity"
                  onClick={() => setCurrentScreen('landing')}
                >
                  Sky<span style={{color: '#FFF099'}}>Fable</span>
                </div>
                <button
                  onClick={handleCycleWeather}
                  className="ml-4 px-3 py-2 rounded-lg font-semibold text-xs border border-yellow-200 bg-white bg-opacity-10 text-yellow-100 hover:bg-opacity-20 transition-all duration-200"
                  style={{minWidth:'120px'}}
                  title="Manually cycle weather for preview"
                >
                  Weather: {effectiveWeatherType.charAt(0).toUpperCase() + effectiveWeatherType.slice(1)}
                </button>
              </nav>

              <div className="flex items-center justify-center min-h-[calc(100vh-120px)] px-4 sm:px-8">
                <div className="flex flex-col lg:flex-row items-center justify-between max-w-7xl w-full gap-8 lg:gap-0">
                  {/* Left Content */}
                  <div className="flex-1 text-center lg:text-left lg:pr-16">
                    <h1 className="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-bold mb-6 leading-tight" style={{color: '#FFF099'}}>
                      <WeatherHeadline weatherType={effectiveWeatherType}>
                        Find your perfect game based on the weather
                      </WeatherHeadline>
                    </h1>
                    
                    <p className="text-lg sm:text-xl mb-6 text-white opacity-90 font-medium leading-relaxed">
                      Let the weather decide your next gaming adventure
                    </p>
                    
                    <div className="flex items-center justify-center lg:justify-start gap-2 mb-8">
                      <span className="text-white opacity-70 text-sm">How does this work?</span>
                      <div className="relative group">
                        <svg 
                          className="w-4 h-4 text-white opacity-50 cursor-help" 
                          fill="currentColor" 
                          viewBox="0 0 20 20"
                        >
                          <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clipRule="evenodd" />
                        </svg>
                        <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none">
                          <div className="bg-gray-900 text-white p-4 rounded-lg shadow-lg text-sm w-72">
                            <div className="font-semibold mb-2">Why weather?</div>
                            <div className="text-gray-200 leading-relaxed">
                              Weather affects our mood and energy levels. Rainy days call for cozy, story-driven games. Sunny weather pairs well with upbeat adventures. We match games to your atmospheric vibe.
                            </div>
                            <div className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900"></div>
                          </div>
                        </div>
                      </div>
                    </div>

                    <button 
                      onClick={handleForecastClick}
                      className="w-full sm:w-auto px-8 py-4 rounded-lg font-bold text-lg transition-all duration-300 hover:scale-105 shadow-lg"
                      style={{
                        backgroundColor: '#FFF099',
                        color: '#504B81'
                      }}
                    >
                      Forecast My Game
                    </button>
                  </div>

                  {/* Right Content - Your Hero Image */}
                  <div className="flex-1 flex justify-center order-first lg:order-last">
                    <img 
                      src="https://raw.githubusercontent.com/PragmaticGit/Skyfable/main/images/hero-image.png" 
                      alt="Gaming illustration" 
                      className="max-w-full h-auto"
                      style={{
                        maxHeight: '300px',
                        width: 'auto',
                        display: 'block'
                      }}
                      onError={(e) => {
                        console.log('GitHub raw URL failed, trying relative path...');
                        e.target.src = "./images/hero-image.png";
                        e.target.onerror = () => {
                          console.log('All paths failed for hero image');
                          e.target.style.display = 'none';
                          e.target.parentNode.innerHTML = '<div style="width: 300px; height: 200px; background: rgba(255,255,255,0.1); border-radius: 16px; display: flex; align-items: center; justify-content: center; color: white; font-size: 18px;">🎮 Gaming</div>';
                        };
                      }}
                    />
                  </div>
                </div>
              </div>
            </div>
          );

          const renderLoading = () => {
            // Determine which status to show based on loadingProgress
            const statusIndex = Math.min(
              Math.floor((loadingProgress / 100) * loadingStatuses.length),
              loadingStatuses.length - 1
            );
            const statusMessage = loadingStatuses[statusIndex];
            return (
              <div className="min-h-screen relative flex flex-col" style={{backgroundColor: '#837EB4'}}>
                <nav className="flex justify-between items-center px-8 py-6" style={{backgroundColor: '#504B81'}}>
                  <div 
                    className="text-white text-2xl font-bold cursor-pointer hover:opacity-80 transition-opacity"
                    onClick={() => setCurrentScreen('landing')}
                  >
                    Sky<span style={{color: '#FFF099'}}>Fable</span>
                  </div>
                  <button 
                    className="px-6 py-3 border-2 rounded-lg font-semibold opacity-50 cursor-not-allowed"
                    style={{
                      borderColor: '#FFF099',
                      color: '#FFF099'
                    }}
                  >
                    Forecast My Game
                  </button>
                </nav>

                <div className="flex-1 flex flex-col items-center justify-center px-8">
                  <h1 className="text-5xl md:text-6xl font-bold mb-8 text-white text-center">
                    Sky<span style={{color: '#FFF099'}}>Fable</span>
                  </h1>
                  
                  <p className="text-2xl mb-8 text-center font-medium pulse-animation" style={{color: '#FFF099'}}>
                    {statusMessage}
                  </p>

                  <div className="mb-8">
                    {/* Minimal SVG spinner */}
                    <svg width="96" height="96" viewBox="0 0 96 96" fill="none" xmlns="http://www.w3.org/2000/svg" className="animate-spin" style={{display: 'block'}}>
                      <circle cx="48" cy="48" r="40" stroke="#504B81" strokeWidth="8" opacity="0.15" />
                      <path d="M88 48a40 40 0 1 1-40-40" stroke="#FFF099" strokeWidth="8" strokeLinecap="round" />
                    </svg>
                  </div>
                </div>
              </div>
            );
          };

          const renderResult = () => (
            <div className="min-h-screen relative overflow-hidden" style={{backgroundColor: '#837EB4'}}>
              <nav className="flex justify-between items-center px-8 py-6 relative z-10" style={{backgroundColor: '#504B81'}}>
                <div 
                  className="text-white text-2xl font-bold cursor-pointer hover:opacity-80 transition-opacity"
                  onClick={() => setCurrentScreen('landing')}
                >
                  Sky<span style={{color: '#FFF099'}}>Fable</span>
                </div>
                <button 
                  onClick={() => setCurrentScreen('landing')}
                  className="px-6 py-3 border-2 rounded-lg font-semibold transition-all duration-300"
                  style={{
                    borderColor: '#FFF099',
                    color: '#FFF099'
                  }}
                >
                  Forecast My Game
                </button>
              </nav>

              <div className="flex items-center justify-center min-h-[calc(100vh-120px)] px-4 sm:px-8">
                <div className="flex flex-col lg:flex-row items-center justify-between max-w-7xl w-full gap-8 lg:gap-0">
                  {/* Game Card */}
                  <div className="flex-shrink-0 order-first lg:order-first lg:mr-16">
                    <div className="w-80 sm:w-96 h-48 sm:h-56 rounded-lg shadow-2xl overflow-hidden relative bg-gray-900">
                      <img 
                        src={gameRecommendation?.gameImage || "https://cdn.akamai.steamstatic.com/steam/apps/383870/header.jpg"}
                        alt={gameRecommendation?.title || "Game cover"}
                        className="w-full h-full object-cover rounded-lg"
                        style={{objectPosition: 'center'}}
                        onError={(e) => {
                          console.log('Game image failed to load:', e.target.src);
                          e.target.style.display = 'none';
                          e.target.parentNode.style.background = 'linear-gradient(135deg, #F59E0B 0%, #D97706 50%, #B45309 100%)';
                          e.target.parentNode.innerHTML = `
                            <div class="absolute inset-0 flex flex-col items-center justify-center text-center p-8">
                              <div class="text-5xl sm:text-7xl mb-4 sm:mb-6">🎮</div>
                              <h3 class="text-lg sm:text-2xl font-bold text-white mb-2 sm:mb-4 tracking-wide">
                                ${(gameRecommendation?.title || 'GAME').toUpperCase()}
                              </h3>
                              <div class="text-orange-100 font-medium text-xs sm:text-sm leading-relaxed">
                                Image unavailable
                              </div>
                            </div>
                          `;
                        }}
                        onLoad={(e) => {
                          console.log('Game image loaded successfully:', gameRecommendation?.title);
                        }}
                      />
                    </div>
                  </div>

                  {/* Game Info */}
                  <div className="flex-1 text-center lg:text-left">
                    {/* Tags */}
                    <div className="flex flex-wrap justify-center lg:justify-start gap-2 mb-4 sm:mb-6">
                      {(gameRecommendation?.tags || ['Single-player', 'Atmospheric', 'Story-Rich']).map((tag, index) => (
                        <span 
                          key={index}
                          className="px-3 sm:px-4 py-1 sm:py-2 rounded-full text-xs sm:text-sm font-semibold"
                          style={{
                            backgroundColor: '#FFF8CC',
                            color: '#504B81'
                          }}
                        >
                          {tag}
                        </span>
                      ))}
                    </div>

                    {/* Game Title */}
                    <h2 className="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-bold mb-4 sm:mb-6" style={{color: '#FFF099'}}>
                      {gameRecommendation?.title || 'Firewatch'}
                    </h2>

                    {/* Description */}
                    <p className="text-white text-base sm:text-lg leading-relaxed mb-6 sm:mb-8 opacity-90 font-medium">
                      {gameRecommendation?.description || "Today's drizzle sets the mood for something quiet and reflective. Firewatch is a first-person mystery in the Wyoming wilderness, where your only lifeline is a voice on the other end of a radio."}
                    </p>

                    {/* Action Buttons */}
                    <div className="flex flex-col sm:flex-row gap-3 sm:gap-4 justify-center lg:justify-start">
                      <button 
                        onClick={() => window.open(gameRecommendation?.steamUrl || "https://store.steampowered.com/app/383870/Firewatch/", '_blank')}
                        className="w-full sm:w-auto px-6 sm:px-8 py-3 rounded-lg font-bold transition-all duration-300 hover:scale-105 shadow-lg"
                        style={{
                          backgroundColor: '#FFF099',
                          color: '#504B81'
                        }}
                      >
                        View On Steam
                      </button>
                      <button 
                        onClick={handleRollAgain}
                        className="w-full sm:w-auto px-6 sm:px-8 py-3 border-2 rounded-lg font-bold transition-all duration-300"
                        style={{
                          borderColor: '#FFF8CC',
                          color: '#FFF8CC',
                          backgroundColor: 'transparent'
                        }}
                        onMouseEnter={(e) => {
                          e.target.style.backgroundColor = '#FFF8CC';
                          e.target.style.color = '#504B81';
                        }}
                        onMouseLeave={(e) => {
                          e.target.style.backgroundColor = 'transparent';
                          e.target.style.color = '#FFF8CC';
                        }}
                      >
                        Roll Again
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );

          const renderLocationError = () => (
            <div className="min-h-screen relative flex flex-col" style={{backgroundColor: '#837EB4'}}>
              <nav className="flex justify-between items-center px-8 py-6" style={{backgroundColor: '#504B81'}}>
                <div 
                  className="text-white text-2xl font-bold cursor-pointer hover:opacity-80 transition-opacity"
                  onClick={() => setCurrentScreen('landing')}
                >
                  Sky<span style={{color: '#FFF099'}}>Fable</span>
                </div>
                <button 
                  onClick={() => setCurrentScreen('landing')}
                  className="px-6 py-3 border-2 rounded-lg font-semibold transition-all duration-300"
                  style={{
                    borderColor: '#FFF099',
                    color: '#FFF099'
                  }}
                >
                  Back to Home
                </button>
              </nav>

              <div className="flex-1 flex flex-col items-center justify-center px-8">
                <div className="text-center max-w-md">
                  <div className="text-6xl mb-6">📍</div>
                  <h1 className="text-4xl font-bold text-white mb-6">
                    Location Needed
                  </h1>
                  
                  <p className="text-lg mb-8 text-white opacity-90 font-medium leading-relaxed">
                    SkyFable needs your location to check the weather and find the perfect game for you. 
                    Please enable location permissions and try again.
                  </p>

                  <div className="space-y-4">
                    <button 
                      onClick={handleForecastClick}
                      className="w-full px-8 py-3 rounded-lg font-bold transition-all duration-300 hover:scale-105 shadow-lg"
                      style={{
                        backgroundColor: '#FFF099',
                        color: '#504B81'
                      }}
                    >
                      Try Again
                    </button>
                    
                    <button 
                      onClick={() => setCurrentScreen('landing')}
                      className="w-full px-8 py-3 border-2 rounded-lg font-bold transition-all duration-300"
                      style={{
                        borderColor: '#FFF8CC',
                        color: '#FFF8CC',
                        backgroundColor: 'transparent'
                      }}
                    >
                      Back to Home
                    </button>
                  </div>

                  <p className="text-sm text-white opacity-60 mt-6">
                    💡 Tip: Look for the location icon in your browser's address bar
                  </p>
                </div>
              </div>
            </div>
          );

          switch (currentScreen) {
            case 'loading':
              return renderLoading();
            case 'result':
              return renderResult();
            case 'location-error':
              return renderLocationError();
            default:
              return renderLanding();
          }
        };

        ReactDOM.render(React.createElement(SkyFable), document.getElementById('root'));
    </script>
    <a href='https://ko-fi.com/H2H21HEPVU' target='_blank' id="kofi-float-btn">
      <img height='36' style='border:0px;height:36px;' src='https://storage.ko-fi.com/cdn/kofi5.png?v=6' border='0' alt='Buy Me a Coffee at ko-fi.com' />
    </a>
</body>
</html>
