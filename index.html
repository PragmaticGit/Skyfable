<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SkyFable - Weather-Based Game Discovery</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=UnifrakturCook:wght@700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body { 
            font-family: 'Quicksand', sans-serif; 
            background-color: #837EB4;
        }
        .pulse-animation {
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        .loading-spin {
            animation: spin 2s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #kofiwidget2-container {
            position: fixed !important;
            right: 20px !important;
            left: auto !important;
            bottom: 20px !important;
            z-index: 9999 !important;
        }
        #kofi-float-btn {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 9999;
        }
        /* Clear Weather */
        .clear-weather {
            filter: brightness(1.1) contrast(1.1) saturate(1.1);
        }
        /* Cloudy Weather */
        .cloudy-weather {
            filter: brightness(0.98) saturate(0.92);
        }
        .fantasy-title {
            font-family: 'UnifrakturCook', cursive;
            letter-spacing: 1px;
        }
        .card-glow-rain { box-shadow: 0 0 24px 4px rgba(59,130,246,0.25); border: 2px solid #3B82F6; }
        .card-glow-snow { box-shadow: 0 0 24px 4px rgba(219,234,254,0.25); border: 2px solid #DBEAFE; }
        .card-glow-sunny { box-shadow: 0 0 24px 4px rgba(251,191,36,0.25); border: 2px solid #FBBF24; }
        .card-glow-cloudy { box-shadow: 0 0 24px 4px rgba(107,114,128,0.25); border: 2px solid #6B7280; }
        .card-glow-clear { box-shadow: 0 0 32px 6px rgba(234,246,255,0.25); border: 2px solid #EAF6FF; }
        .sf-tooltip {
            position: absolute;
            z-index: 30;
            background: #1a202c;
            color: #fff;
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            transition: opacity 0.2s;
            pointer-events: none;
            box-shadow: 0 8px 32px rgba(0,0,0,0.25);
            border: 1px solid #374151;
            width: 220px;
            bottom: 100%;
            right: 0;
            margin-bottom: 8px;
        }
        @media (max-width: 640px) {
            .sf-tooltip {
                left: 50% !important;
                right: auto !important;
                transform: translateX(-50%);
                min-width: 200px;
                max-width: 90vw;
            }
        }
        @keyframes bounce-slow {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-10px); }
        }
    </style>
</head>
<body>
    <div id="weather-particles-root" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1;pointer-events:none;"></div>
    <div id="weather-special-root" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1;pointer-events:none;"></div>
    <div id="root" style="position:relative;z-index:2;"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // StarfieldCanvas for clear weather
        const StarfieldCanvas = () => {
          const canvasRef = useRef(null);
          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let width = window.innerWidth;
            let height = window.innerHeight;
            let dpr = window.devicePixelRatio || 1;
            let stars = [];
            const STAR_COUNT = 60;
            const SPARKLE_COUNT = 8;
            // Generate stars
            const createStars = () => {
              stars = [];
              for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                  x: Math.random() * width,
                  y: Math.random() * height,
                  r: 0.5 + Math.random() * 1.2,
                  speedX: (Math.random() - 0.5) * 0.03,
                  speedY: (Math.random() - 0.5) * 0.03,
                  alpha: 0.7 + Math.random() * 0.3
                });
              }
              // Add geometric sparkles
              for (let i = 0; i < SPARKLE_COUNT; i++) {
                stars.push({
                  sparkle: true,
                  x: Math.random() * width,
                  y: Math.random() * height * 0.8,
                  size: 7 + Math.random() * 7,
                  twinklePhase: Math.random() * Math.PI * 2
                });
              }
            };
            createStars();
            // Set canvas size
            const setCanvasSize = () => {
              dpr = window.devicePixelRatio || 1;
              width = window.innerWidth;
              height = window.innerHeight;
              canvas.width = width * dpr;
              canvas.height = height * dpr;
              canvas.style.width = width + 'px';
              canvas.style.height = height + 'px';
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.scale(dpr, dpr);
              createStars();
            };
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);
            // Animation loop
            let anim;
            const animate = () => {
              ctx.clearRect(0, 0, width, height);
              // Draw stars
              for (let s of stars) {
                if (s.sparkle) continue;
                ctx.save();
                ctx.globalAlpha = s.alpha;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, 2 * Math.PI);
                ctx.fillStyle = '#eaf6ff';
                ctx.shadowColor = '#eaf6ff';
                ctx.shadowBlur = 4;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
                s.x += s.speedX;
                s.y += s.speedY;
                if (s.x < 0) s.x = width;
                if (s.x > width) s.x = 0;
                if (s.y < 0) s.y = height;
                if (s.y > height) s.y = 0;
              }
              // Draw sparkles (diamond/star shapes)
              for (let s of stars) {
                if (!s.sparkle) continue;
                const twinkle = 0.7 + 0.3 * Math.sin(Date.now() * 0.001 + s.twinklePhase);
                ctx.save();
                ctx.globalAlpha = twinkle * 0.8;
                ctx.translate(s.x, s.y);
                ctx.rotate(Math.PI / 4);
                ctx.beginPath();
                ctx.moveTo(0, -s.size * 0.5);
                ctx.lineTo(s.size * 0.2, 0);
                ctx.lineTo(0, s.size * 0.5);
                ctx.lineTo(-s.size * 0.2, 0);
                ctx.closePath();
                ctx.fillStyle = '#eaf6ff';
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 8 * twinkle;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
              }
              anim = requestAnimationFrame(animate);
            };
            animate();
            return () => {
              window.removeEventListener('resize', setCanvasSize);
              cancelAnimationFrame(anim);
            };
          }, []);
          return (
            <canvas ref={canvasRef} style={{position:'fixed',top:0,left:0,width:'100vw',height:'100vh',zIndex:0,pointerEvents:'none'}} />
          );
        };

        // WeatherOverlay: ambient color gradient overlay
        const WeatherOverlay = ({ weatherType }) => {
          // Define gradients for each weather type
          const gradients = {
            rain: 'linear-gradient(120deg, rgba(80,90,180,0.18) 0%, rgba(120,180,255,0.22) 100%)',
            snow: 'linear-gradient(120deg, rgba(200,220,255,0.13) 0%, rgba(180,180,255,0.18) 100%)',
            sunny: 'linear-gradient(120deg, rgba(255,200,100,0.13) 0%, rgba(255,240,180,0.12) 100%)',
            cloudy: 'linear-gradient(120deg, rgba(120,120,180,0.13) 0%, rgba(180,180,200,0.13) 100%)',
            fog: 'linear-gradient(120deg, rgba(180,180,200,0.10) 0%, rgba(200,200,220,0.13) 100%)',
            clear: 'linear-gradient(120deg, rgba(130,120,255,0.08) 0%, rgba(255,255,255,0.08) 100%)'
          };
          const style = {
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100vw',
            height: '100vh',
            zIndex: 1,
            pointerEvents: 'none',
            transition: 'background 0.8s cubic-bezier(.4,0,.2,1)',
            background: gradients[weatherType] || gradients.clear
          };
          return <div style={style} />;
        };

        // WeatherHeadline: main headline with minimal weather effect
        const WeatherHeadline = ({ weatherType, children }) => {
          // Rain: subtle drip on descenders; Sunny: gentle glow; Snow: sparkles
          if (weatherType === 'rain') {
            return (
              <span className="weather-headline-rain" style={{position:'relative',display:'inline-block'}}>
                {children}
                <style>{`
                  .weather-headline-rain .drip {
                    position: absolute;
                    width: 3px;
                    height: 12px;
                    background: linear-gradient(to bottom, #FFF8CC 60%, rgba(255,255,255,0));
                    border-radius: 2px;
                    left: 0.32em;
                    top: 1.1em;
                    opacity: 0.10;
                    animation: drip-fall 2.8s infinite linear;
                  }
                  @keyframes drip-fall {
                    0% { opacity: 0.10; transform: translateY(0); }
                    80% { opacity: 0.10; }
                    100% { opacity: 0; transform: translateY(12px); }
                  }
                `}</style>
                <span className="drip" />
              </span>
            );
          } else if (weatherType === 'sunny') {
            return (
              <span className="weather-headline-sunny" style={{position:'relative',display:'inline-block',textShadow:'0 0 4px #ffe9a0, 0 0 1px #fff099'}}>
                {children}
                <style>{`
                  .weather-headline-sunny {
                    animation: sunny-glow 3.5s infinite alternate;
                  }
                  @keyframes sunny-glow {
                    0% { text-shadow: 0 0 2px #ffe9a0, 0 0 1px #fff099; }
                    100% { text-shadow: 0 0 8px #ffe9a0, 0 0 3px #fff099; }
                  }
                `}</style>
              </span>
            );
          } else if (weatherType === 'snow') {
            return <span>{children}</span>;
          } else {
            return <span>{children}</span>;
          }
        };

        // CloudyCanvas: advanced, organic, rolling misty clouds (video-inspired, optimized)
        const CloudyCanvas = () => {
          const canvasRef = React.useRef(null);
          React.useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let dpr = window.devicePixelRatio || 1;
            let scale = 0.5; // Render at 50% resolution
            let width = window.innerWidth * scale;
            let height = window.innerHeight * scale;
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = '100vw';
            canvas.style.height = '100vh';

            function handleResize() {
              width = window.innerWidth * scale;
              height = window.innerHeight * scale;
              canvas.width = width;
              canvas.height = height;
            }
            window.addEventListener('resize', handleResize);

            // Fewer clouds for better performance
            const LAYERS = 3;
            const CLOUDS_PER_LAYER = 4;
            let clouds = [];
            for (let l = 0; l < LAYERS; l++) {
              for (let i = 0; i < CLOUDS_PER_LAYER; i++) {
                clouds.push({
                  layer: l,
                  x: Math.random() * width,
                  y: height * (0.1 + 0.8 * Math.random()),
                  r: (180 + Math.random() * 120 + l * 40) * scale,
                  dx: (0.08 + Math.random() * 0.10) * (l % 2 ? 1 : -1) * (0.7 + l * 0.2) * scale,
                  dy: (Math.random() - 0.5) * 0.04 * (l + 1) * scale,
                  alpha: 0.07 + Math.random() * 0.07 + l * 0.02,
                  baseAlpha: 0.07 + Math.random() * 0.07 + l * 0.02,
                  phase: Math.random() * Math.PI * 2,
                  speed: 0.0007 + Math.random() * 0.0007 + l * 0.0002,
                });
              }
            }

            let anim;
            let lastDraw = 0;
            function draw(now) {
              if (now - lastDraw > 33) { // ~30fps
                ctx.clearRect(0, 0, width, height);
                for (let c of clouds) {
                  // Animate organic rolling
                  let t = Date.now();
                  let offsetX = Math.sin(t * c.speed + c.phase) * 30 * (1 + c.layer * 0.2) * scale;
                  let offsetY = Math.cos(t * c.speed * 0.7 + c.phase) * 18 * (1 + c.layer * 0.1) * scale;
                  let x = c.x + offsetX;
                  let y = c.y + offsetY;
                  // Animate horizontal drift
                  c.x += c.dx;
                  c.y += c.dy;
                  if (c.dx > 0 && c.x - c.r > width + 40 * scale) c.x = -c.r;
                  if (c.dx < 0 && c.x + c.r < -40 * scale) c.x = width + c.r;
                  if (c.y - c.r > height + 40 * scale) c.y = -c.r;
                  if (c.y + c.r < -40 * scale) c.y = height + c.r;
                  // Alpha pulse for depth
                  let alpha = c.baseAlpha + Math.sin(t * c.speed * 0.6 + c.phase) * 0.03;
                  // Soft radial gradient
                  let grad = ctx.createRadialGradient(x, y, c.r * 0.2, x, y, c.r);
                  grad.addColorStop(0, `rgba(180,190,220,${alpha})`);
                  grad.addColorStop(0.7, `rgba(180,190,220,${alpha * 0.5})`);
                  grad.addColorStop(1, 'rgba(180,190,220,0)');
                  ctx.save();
                  ctx.globalAlpha = 1;
                  ctx.beginPath();
                  ctx.arc(x, y, c.r, 0, 2 * Math.PI);
                  ctx.fillStyle = grad;
                  ctx.fill();
                  ctx.restore();
                }
                lastDraw = now;
              }
              anim = requestAnimationFrame(draw);
            }
            draw(performance.now());
            return () => {
              window.removeEventListener('resize', handleResize);
              cancelAnimationFrame(anim);
            };
          }, []);
          return (
            <canvas
              ref={canvasRef}
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                width: '100vw',
                height: '100vh',
                zIndex: 1,
                pointerEvents: 'none',
                transition: 'opacity 0.8s',
              }}
            />
          );
        };

        // WeatherSpecialEffects: for clear/cloudy backgrounds
        const WeatherSpecialEffects = ({ weatherType }) => {
          // Clear: just static filter, no particles or background effects
          if (weatherType === 'clear') {
            return <>
              <div style={{position:'fixed',top:0,left:0,width:'100vw',height:'100vh',zIndex:2,pointerEvents:'none',background:'transparent',filter:'brightness(1.1) contrast(1.1) saturate(1.1)'}} />
              <style>{`
                body.clear-ui .card-clear-effect {
                  box-shadow: 0 0 0 2px #eaf6ff, 0 4px 32px 0 rgba(130,180,255,0.10);
                  border: 1.5px solid #eaf6ff !important;
                }
              `}</style>
            </>;
          }
          // Cloudy: use CloudyCanvas for fun, stylized clouds
          if (weatherType === 'cloudy') {
            return <CloudyCanvas />;
          }
          return null;
        };

        // WeatherParticles: CSS/Canvas-based background particles for rain, snow, sunny
        const WeatherParticles = ({ weatherType }) => {
          const canvasRef = useRef(null);
          useEffect(() => {
            // Only render for rain, snow, sunny
            if (weatherType !== 'rain' && weatherType !== 'snow' && weatherType !== 'sunny') return;
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let width = window.innerWidth;
            let height = window.innerHeight;
            let dpr = window.devicePixelRatio || 1;
            let particles = [];
            // Configs
            const configs = {
              rain: {
                count: 60,
                color: 'rgba(255,255,255,0.18)',
                speed: [2, 4],
                length: [16, 32],
                width: 1.2
              },
              snow: {
                count: 40,
                color: 'rgba(255,255,255,0.13)',
                speed: [0.5, 1.2],
                size: [2, 5]
              },
              sunny: {
                count: 18,
                color: 'rgba(255, 200, 80, 0.13)',
                speed: [0.3, 0.7],
                size: [2, 4]
              }
            };
            // Generate initial particles
            const createParticles = (type, w, h) => {
              const arr = [];
              if (type === 'rain') {
                for (let i = 0; i < configs.rain.count; i++) {
                  arr.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    l: configs.rain.length[0] + Math.random() * (configs.rain.length[1] - configs.rain.length[0]),
                    speed: configs.rain.speed[0] + Math.random() * (configs.rain.speed[1] - configs.rain.speed[0])
                  });
                }
              } else if (type === 'snow') {
                for (let i = 0; i < configs.snow.count; i++) {
                  arr.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    r: configs.snow.size[0] + Math.random() * (configs.snow.size[1] - configs.snow.size[0]),
                    speed: configs.snow.speed[0] + Math.random() * (configs.snow.speed[1] - configs.snow.speed[0]),
                    drift: (Math.random() - 0.5) * 0.5
                  });
                }
              } else if (type === 'sunny') {
                for (let i = 0; i < configs.sunny.count; i++) {
                  arr.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    r: configs.sunny.size[0] + Math.random() * (configs.sunny.size[1] - configs.sunny.size[0]),
                    speed: configs.sunny.speed[0] + Math.random() * (configs.sunny.speed[1] - configs.sunny.speed[0]),
                    alpha: 0.5 + Math.random() * 0.3
                  });
                }
              }
              return arr;
            };
            // Set canvas size
            const setCanvasSize = () => {
              dpr = window.devicePixelRatio || 1;
              width = window.innerWidth;
              height = window.innerHeight;
              canvas.width = width * dpr;
              canvas.height = height * dpr;
              canvas.style.width = width + 'px';
              canvas.style.height = height + 'px';
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.scale(dpr, dpr);
              particles = createParticles(weatherType, width, height);
            };
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);
            // Animation loop
            let anim;
            const animate = () => {
              ctx.clearRect(0, 0, width, height);
              if (weatherType === 'rain') {
                ctx.strokeStyle = configs.rain.color;
                ctx.lineWidth = configs.rain.width;
                for (let p of particles) {
                  ctx.beginPath();
                  ctx.moveTo(p.x, p.y);
                  ctx.lineTo(p.x, p.y + p.l);
                  ctx.stroke();
                  p.y += p.speed;
                  if (p.y > height) {
                    p.x = Math.random() * width;
                    p.y = -p.l;
                  }
                }
              } else if (weatherType === 'snow') {
                ctx.fillStyle = configs.snow.color;
                for (let p of particles) {
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);
                  ctx.fill();
                  p.y += p.speed;
                  p.x += p.drift;
                  if (p.y > height) {
                    p.x = Math.random() * width;
                    p.y = -p.r;
                  }
                  if (p.x < 0) p.x = width;
                  if (p.x > width) p.x = 0;
                }
              } else if (weatherType === 'sunny') {
                for (let p of particles) {
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);
                  ctx.fillStyle = `rgba(255, 200, 80, ${p.alpha})`;
                  ctx.shadowColor = '#FFD580';
                  ctx.shadowBlur = 6;
                  ctx.fill();
                  ctx.shadowBlur = 0;
                  p.y -= p.speed * 0.5;
                  if (p.y < -p.r) {
                    p.x = Math.random() * width;
                    p.y = height + p.r;
                  }
                }
              }
              anim = requestAnimationFrame(animate);
            };
            animate();
            return () => {
              window.removeEventListener('resize', setCanvasSize);
              cancelAnimationFrame(anim);
            };
          }, [weatherType]);
          if (weatherType !== 'rain' && weatherType !== 'snow' && weatherType !== 'sunny') return null;
          return (
            <canvas ref={canvasRef} style={{position:'fixed',top:0,left:0,width:'100vw',height:'100vh',zIndex:0,pointerEvents:'none'}} />
          );
        };

        const HeroWeather3D = ({ weatherType, weather }) => {
    if (typeof window.THREE === "undefined") {
        return (
            <div className="flex items-center justify-center w-full h-[220px] sm:h-[280px] lg:h-[340px] xl:h-[400px] bg-black/10 rounded-lg">
                <span className="text-white/70">3D Weather unavailable (Three.js not loaded)</span>
            </div>
        );
    }
    const mountRef = React.useRef(null);
    const sceneRef = React.useRef(null);
    const rendererRef = React.useRef(null);
    const weatherObjectRef = React.useRef(null);
    const animationIdRef = React.useRef(null);
    const canvasSizeRef = React.useRef(0);

    function createCloudGroup({ color, count, scaleRange, spread }) {
        const group = new THREE.Group();
        const geometry = new THREE.SphereGeometry(1, 16, 16);
        const material = new THREE.MeshLambertMaterial({ color, transparent: true, opacity: 0.8 });
        for (let i = 0; i < count; i++) {
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(
                (Math.random() - 0.5) * spread.x,
                (Math.random() - 0.5) * spread.y,
                (Math.random() - 0.5) * spread.z
            );
            const scale = scaleRange[0] + Math.random() * (scaleRange[1] - scaleRange[0]);
            mesh.scale.setScalar(scale);
            group.add(mesh);
        }
        return group;
    }
    const weather3DConfig = {
        sunny: (THREE) => {
            const sun = new THREE.Mesh(
                new THREE.SphereGeometry(1.2, 32, 32),
                new THREE.MeshLambertMaterial({ color: 0xFFD700, emissive: 0xFFAA00, emissiveIntensity: 0.3 })
            );
            const rayGroup = new THREE.Group();
            const rayGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.8, 8);
            const rayMaterial = new THREE.MeshLambertMaterial({ color: 0xFFE55C, emissive: 0xFFD700, emissiveIntensity: 0.2 });
            for (let i = 0; i < 8; i++) {
                const ray = new THREE.Mesh(rayGeometry, rayMaterial);
                ray.position.set(Math.cos(i * Math.PI / 4) * 2, Math.sin(i * Math.PI / 4) * 2, 0);
                ray.rotation.z = i * Math.PI / 4;
                rayGroup.add(ray);
            }
            const group = new THREE.Group();
            group.add(sun);
            group.add(rayGroup);
            group.userData = { animate: (g) => { g.children[1].rotation.z += 0.02; } };
            return group;
        },
        rain: (THREE) => {
            const group = createCloudGroup({ color: 0x87CEEB, count: 5, scaleRange: [0.6, 1.0], spread: { x: 2, y: 0.5, z: 0.5 } });
            const dropGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
            const dropMaterial = new THREE.MeshLambertMaterial({ color: 0x4A90E2, transparent: true, opacity: 0.7 });
            for (let i = 0; i < 12; i++) {
                const drop = new THREE.Mesh(dropGeometry, dropMaterial);
                drop.position.set((Math.random() - 0.5) * 3, -1.5 - Math.random() * 2, (Math.random() - 0.5) * 0.5);
                group.add(drop);
            }
            group.userData = { animate: (g) => { g.position.y = Math.sin(Date.now() * 0.001) * 0.1; } };
            return group;
        },
        snow: (THREE) => {
            const group = createCloudGroup({ color: 0xF0F8FF, count: 4, scaleRange: [0.7, 1.0], spread: { x: 1.5, y: 0.3, z: 0.3 } });
            const flakeGeometry = new THREE.OctahedronGeometry(0.08, 0);
            const flakeMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 });
            for (let i = 0; i < 20; i++) {
                const flake = new THREE.Mesh(flakeGeometry, flakeMaterial);
                flake.position.set((Math.random() - 0.5) * 4, -1 - Math.random() * 3, (Math.random() - 0.5) * 1);
                group.add(flake);
            }
            group.userData = { animate: (g) => { g.position.y = Math.sin(Date.now() * 0.001) * 0.1; } };
            return group;
        },
        cloudy: (THREE) => {
            const group = createCloudGroup({ color: 0x696969, count: 6, scaleRange: [0.5, 1.0], spread: { x: 2.5, y: 0.8, z: 0.8 } });
            return group;
        },
        clear: (THREE) => {
            const mesh = new THREE.Mesh(
                new THREE.OctahedronGeometry(1.2, 1),
                new THREE.MeshLambertMaterial({ color: 0x9370DB, transparent: true, opacity: 0.8, emissive: 0x4B0082, emissiveIntensity: 0.2 })
            );
            return mesh;
        }
    };

    React.useEffect(() => {
        if (!mountRef.current) return;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const container = mountRef.current;
        // Responsive sizing
        const getResponsiveSize = () => {
            const defaultSize = 220;
            let width = container.clientWidth || defaultSize;
            let height = container.clientHeight || defaultSize;
            let size = Math.min(width, height, 400);
            if (!size || size < 80) size = defaultSize;
            return size;
        };
        let size = getResponsiveSize();
        renderer.setSize(size, size);
        renderer.setClearColor(0xff00ff, 1); // Bright magenta for debug
        container.appendChild(renderer.domElement);
        canvasSizeRef.current = size;
        console.log('Three.js canvas appended:', renderer.domElement, 'size:', size);

        sceneRef.current = scene;
        rendererRef.current = renderer;

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 10, 5);
        scene.add(dirLight);

        const createObj = weather3DConfig[weatherType] || weather3DConfig.clear;
        const weatherObj = createObj(THREE);
        scene.add(weatherObj);
        weatherObjectRef.current = weatherObj;

        camera.position.z = 5;

        const animate = () => {
            if (weatherObjectRef.current) {
                weatherObjectRef.current.rotation.y += 0.01;
                weatherObjectRef.current.rotation.x += 0.005;
                if (weatherObjectRef.current.userData.animate) {
                    weatherObjectRef.current.userData.animate(weatherObjectRef.current);
                }
            }
            renderer.render(scene, camera);
            animationIdRef.current = requestAnimationFrame(animate);
        };
        animate();

        // Responsive resize
        const handleResize = () => {
            let newSize = getResponsiveSize();
            renderer.setSize(newSize, newSize);
            canvasSizeRef.current = newSize;
        };
        window.addEventListener('resize', handleResize);
        // Use ResizeObserver for container changes
        let resizeObserver = new window.ResizeObserver(handleResize);
        resizeObserver.observe(container);

        return () => {
            window.removeEventListener('resize', handleResize);
            resizeObserver.disconnect();
            if (animationIdRef.current) cancelAnimationFrame(animationIdRef.current);
            if (container && renderer.domElement && container.contains(renderer.domElement)) {
                container.removeChild(renderer.domElement);
            }
            renderer.dispose();
        };
    }, [weatherType]);

    return (
        <div className="w-full min-w-[120px] min-h-[180px] max-w-[400px] max-h-[400px] sm:min-w-[180px] sm:min-h-[220px] sm:max-w-[400px] sm:max-h-[340px] lg:max-w-[520px] lg:max-h-[340px] xl:max-w-[600px] xl:max-h-[400px] relative flex items-center justify-center border-2 border-dashed border-yellow-400 mx-auto">
            <div
                ref={mountRef}
                className="w-full h-[180px] sm:h-[220px] lg:h-[340px] xl:h-[400px]"
                style={{ filter: 'drop-shadow(0 4px 20px rgba(0,0,0,0.3))' }}
            />
            <span className="absolute text-yellow-400 text-lg font-bold z-10">3D Weather Area</span>
        </div>
    );
};

        const SkyFable = () => {
          const [currentScreen, setCurrentScreen] = useState('landing');
          const [weather, setWeather] = useState(null);
          const [location, setLocation] = useState(null);
          const [gameRecommendation, setGameRecommendation] = useState(null);
          const [loadingProgress, setLoadingProgress] = useState(0);
          const [lastGameTitle, setLastGameTitle] = useState(null);
          const [locationError, setLocationError] = useState(false);
          const [gameCache, setGameCache] = useState({}); // Cache for loaded game databases
          const [weatherType, setWeatherType] = useState('clear');
          const [weatherLoaded, setWeatherLoaded] = useState(false);

          // Extract Steam App ID from Steam URL
          const extractSteamAppId = (steamUrl) => {
            if (!steamUrl) return null;
            const match = steamUrl.match(/\/app\/(\d+)\//);
            return match ? match[1] : null;
          };

          // Get best header-format image (optimized for 460x215 aspect ratio)
          const getOptimizedGameImage = (game) => {
            const steamId = extractSteamAppId(game?.steamUrl);
            if (steamId) {
              // Try higher resolution header format first (same 2.14:1 aspect ratio, better quality)
              return `https://cdn.akamai.steamstatic.com/steam/apps/${steamId}/capsule_616x353.jpg`;
            }
            // Fallback to original header image
            return game?.gameImage || "https://cdn.akamai.steamstatic.com/steam/apps/383870/header.jpg";
          };

          // Fun status messages for loading
          const loadingStatuses = [
            "Consulting the weather spirits...",
            "Rolling the dice of fate...",
            "Matching your mood with the perfect game...",
            "Summoning pixelated adventures...",
            "Almost there, preparing your quest..."
          ];

          const getWeatherType = (condition, temp = 20) => {
            const lowerCondition = condition.toLowerCase();
            console.log('Weather condition received:', condition, 'Temperature:', temp);
            
            let weatherType = 'clear';
            
            if (lowerCondition.includes('rain') || lowerCondition.includes('drizzle') || 
                lowerCondition.includes('shower') || lowerCondition.includes('storm')) {
              weatherType = 'rain';
            } else if (lowerCondition.includes('snow') || lowerCondition.includes('blizzard')) {
              weatherType = 'snow';
            } else if (lowerCondition.includes('cloud') || lowerCondition.includes('overcast')) {
              weatherType = 'cloudy';
            } else if (lowerCondition.includes('clear')) {
              weatherType = 'clear';
            } else if (lowerCondition.includes('sun') || (temp > 25)) {
              weatherType = 'sunny';
            } else if (lowerCondition.includes('fog') || lowerCondition.includes('mist')) {
              weatherType = 'cloudy';
            }
            
            console.log('Determined weather type:', weatherType);
            return weatherType;
          };

          // Load games from JSON file for specific weather type
          const loadGamesForWeather = async (weatherType) => {
            // Check cache first
            if (gameCache[weatherType]) {
              console.log(`Using cached games for ${weatherType}`);
              return gameCache[weatherType];
            }

            try {
              console.log(`Loading games for weather type: ${weatherType}`);
              const response = await fetch(`${weatherType}-games.json`);
              
              if (!response.ok) {
                throw new Error(`Failed to load ${weatherType} games`);
              }
              
              const data = await response.json();
              console.log(`Loaded ${data.games.length} games for ${weatherType}`);
              
              // Cache the result
              setGameCache(prev => ({
                ...prev,
                [weatherType]: data.games
              }));
              
              return data.games;
            } catch (error) {
              console.error(`Error loading ${weatherType} games:`, error);
              // Return fallback games if JSON loading fails
              return getFallbackGames(weatherType);
            }
          };

          // Fallback games in case JSON files fail to load
          const getFallbackGames = (weatherType) => {
            const fallbackGames = {
              rain: [{
                id: "firewatch_fallback",
                title: "Firewatch",
                tags: ["Single-player", "Atmospheric", "Story-Rich"],
                description: "A first-person mystery in the Wyoming wilderness. Perfect for rainy day contemplation.",
                steamUrl: "https://store.steampowered.com/app/383870/Firewatch/",
                gameImage: "https://cdn.akamai.steamstatic.com/steam/apps/383870/header.jpg",
                weatherScore: 9,
                rating: 79
              }],
              sunny: [{
                id: "no_mans_sky_fallback",
                title: "No Man's Sky",
                tags: ["Space", "Exploration", "Colorful"],
                description: "Explore vibrant alien worlds under exotic skies. Perfect for sunny day adventures.",
                steamUrl: "https://store.steampowered.com/app/275850/No_Mans_Sky/",
                gameImage: "https://cdn.akamai.steamstatic.com/steam/apps/275850/header.jpg",
                weatherScore: 9,
                rating: 71
              }],
              cloudy: [{
                id: "control_fallback",
                title: "Control",
                tags: ["Supernatural", "Mysterious", "Paranormal"],
                description: "Navigate supernatural phenomena in a mysterious building. Perfect for cloudy contemplation.",
                steamUrl: "https://store.steampowered.com/app/870780/Control_Ultimate_Edition/",
                gameImage: "https://cdn.akamai.steamstatic.com/steam/apps/870780/header.jpg",
                weatherScore: 9,
                rating: 82
              }],
              snow: [{
                id: "long_dark_fallback",
                title: "The Long Dark",
                tags: ["Survival", "Winter", "Atmospheric"],
                description: "Ultimate winter survival experience. Perfect for appreciating your warm shelter.",
                steamUrl: "https://store.steampowered.com/app/305620/The_Long_Dark/",
                gameImage: "https://cdn.akamai.steamstatic.com/steam/apps/305620/header.jpg",
                weatherScore: 10,
                rating: 78
              }],
              clear: [{
                id: "journey_fallback",
                title: "Journey",
                tags: ["Transcendent", "Beautiful", "Meditative"],
                description: "A wordless adventure that captures the wonder of perfect weather.",
                steamUrl: "https://store.steampowered.com/app/638230/Journey/",
                gameImage: "https://cdn.akamai.steamstatic.com/steam/apps/638230/header.jpg",
                weatherScore: 10,
                rating: 92
              }]
            };
            
            return fallbackGames[weatherType] || fallbackGames.clear;
          };

          // Fisher-Yates shuffle
          function shuffleArray(array) {
            const arr = array.slice();
            for (let i = arr.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
          }

          const selectRandomGame = async (weatherType, avoidTitle = null) => {
            const availableGames = await loadGamesForWeather(weatherType);
            console.log('[DEBUG] Available games for', weatherType, ':', availableGames.map(g => g.title));
            console.log('[DEBUG] lastGameTitle to avoid:', avoidTitle);
            let gamesToChooseFrom;
            if (availableGames.length <= 1 || !avoidTitle) {
              gamesToChooseFrom = availableGames;
            } else {
              const filteredGames = availableGames.filter(game => game.title !== avoidTitle);
              gamesToChooseFrom = filteredGames.length > 0 ? filteredGames : availableGames;
            }
            // Shuffle before picking
            const shuffled = shuffleArray(gamesToChooseFrom);
            const randomIndex = Math.floor(Math.random() * shuffled.length);
            const randomGame = shuffled[randomIndex];
            console.log('[DEBUG] Shuffled games:', shuffled.map(g => g.title));
            console.log('[DEBUG] Random index chosen:', randomIndex);
            console.log('[DEBUG] Selected game:', randomGame.title);
            return randomGame;
          };

          const fetchWeather = async (lat, lon) => {
            try {
              const apiKey = "20f1dd508d4b4bceb7e113102251207";
              const url = `https://api.weather.com/v3/wx/conditions/current?geocode=${lat},${lon}&format=json&language=en-US&units=m&apiKey=${apiKey}`;
              const response = await fetch(url);

              if (!response.ok) {
                throw new Error('Weather fetch failed');
              }

              const data = await response.json();

              return {
                weather: [{
                  main: data.narrative || data.wxPhraseLong || "Unknown",
                  description: (data.narrative || data.wxPhraseLong || "Unknown").toLowerCase()
                }],
                name: data.city || data.neighborhood || "Your Location",
                main: {
                  temp: Math.round(data.temperature)
                }
              };
            } catch (error) {
              console.error('Weather API failed, using fallback:', error);
              return {
                weather: [{ main: 'Rain', description: 'rainy evening' }],
                name: 'Stavanger',
                main: { temp: 18 }
              };
            }
          };

          const getLocation = () => {
            return new Promise((resolve, reject) => {
              if (!navigator.geolocation) {
                console.log('Geolocation not supported, using fallback');
                resolve({ lat: 59.9139, lon: 10.7522 });
                return;
              }

              navigator.geolocation.getCurrentPosition(
                (position) => {
                  console.log('Location permission granted');
                  setLocationError(false);
                  resolve({
                    lat: position.coords.latitude,
                    lon: position.coords.longitude
                  });
                },
                (error) => {
                  console.error('Geolocation error:', error);
                  if (error.code === error.PERMISSION_DENIED) {
                    console.log('Location permission denied by user');
                    setLocationError(true);
                    reject(new Error('Location permission denied'));
                  } else {
                    console.log('Location error, using fallback');
                    resolve({ lat: 59.9139, lon: 10.7522 });
                  }
                }
              );
            });
          };

          const handleForecastClick = async () => {
            setCurrentScreen('loading');
            setLoadingProgress(0);
            const progressInterval = setInterval(() => {
              setLoadingProgress(prev => {
                if (prev >= 90) {
                  clearInterval(progressInterval);
                  return 90;
                }
                return prev + Math.random() * 25;
              });
            }, 150);
            try {
              // Always use effectiveWeatherType (manual or real)
              const randomGame = await selectRandomGame(effectiveWeatherType);
              setGameRecommendation(randomGame);
              setLastGameTitle(randomGame.title);
              setTimeout(() => {
                setLoadingProgress(100);
                setTimeout(() => {
                  setCurrentScreen('result');
                }, 300);
              }, 1200);
            } catch (error) {
              console.error('Error fetching data:', error);
              clearInterval(progressInterval);
              
              if (error.message === 'Location permission denied') {
                setTimeout(() => {
                  setCurrentScreen('location-error');
                }, 1000);
              } else {
                const allWeatherTypes = ['rain', 'sunny', 'cloudy', 'snow', 'clear'];
                const randomWeatherType = allWeatherTypes[Math.floor(Math.random() * allWeatherTypes.length)];
                console.log('Using fallback weather type:', randomWeatherType);
                
                const fallbackGame = await selectRandomGame(randomWeatherType);
                setGameRecommendation(fallbackGame);
                setLastGameTitle(fallbackGame.title);
                
                setWeather({
                  weather: [{ main: 'Unknown', description: 'weather unavailable' }],
                  name: 'Your Location',
                  main: { temp: 20 }
                });
                
                setTimeout(() => {
                  setLoadingProgress(100);
                  setTimeout(() => {
                    setCurrentScreen('result');
                  }, 300);
                }, 1200);
              }
            }
          };

          const handleRollAgain = async () => {
            setCurrentScreen('loading');
            setLoadingProgress(0);
            const progressInterval = setInterval(() => {
              setLoadingProgress(prev => {
                if (prev >= 90) {
                  clearInterval(progressInterval);
                  return 90;
                }
                return prev + Math.random() * 20;
              });
            }, 200);
            setTimeout(async () => {
              if (weather) {
                const weatherType = getWeatherType(weather.weather[0].main, weather.main.temp);
                console.log('[DEBUG] handleRollAgain weatherType:', weatherType);
                console.log('[DEBUG] handleRollAgain lastGameTitle:', lastGameTitle);
                const randomGame = await selectRandomGame(weatherType, lastGameTitle);
                setGameRecommendation(randomGame);
                setLastGameTitle(randomGame.title);
              }
              setLoadingProgress(100);
              setTimeout(() => {
                setCurrentScreen('result');
              }, 300);
            }, 1200);
          };

          useEffect(() => {
            const loadInitialWeather = async () => {
              try {
                const userLocation = await getLocation();
                setLocation(userLocation);
                const weatherData = await fetchWeather(userLocation.lat, userLocation.lon);
                setWeather(weatherData);
                setWeatherLoaded(true);
              } catch (error) {
                console.error('Failed to load initial weather:', error);
                setWeatherLoaded(true);
              }
            };

            loadInitialWeather();
          }, []);

          // Update weatherType when weather changes
          useEffect(() => {
            if (manualWeather) return; // Don't update weatherType if user has manually selected
            if (weather && weather.weather && weather.main) {
              setWeatherType(getWeatherType(weather.weather[0].main, weather.main.temp));
            }
          }, [weather, manualWeather]);

          // Render particles and overlay globally
          useEffect(() => {
            const root = document.getElementById('weather-particles-root');
            if (root) ReactDOM.render(<WeatherParticles weatherType={weatherType} />, root);
            const overlayRoot = document.getElementById('weather-overlay-root');
            if (overlayRoot) React.render(<WeatherOverlay weatherType={weatherType} />, overlayRoot);
            return () => {
              if (root) ReactDOM.unmountComponentAtNode(root);
              if (overlayRoot) ReactDOM.unmountComponentAtNode(overlayRoot);
            };
          }, [weatherType]);

          // Render special effects globally
          useEffect(() => {
            const root = document.getElementById('weather-special-root');
            if (root) ReactDOM.render(<WeatherSpecialEffects weatherType={weatherType} />, root);
            return () => { if (root) ReactDOM.unmountComponentAtNode(root); };
          }, [weatherType]);

          // In renderLanding, add a button to manually cycle weatherType
          const availableWeatherTypes = ['rain', 'sunny', 'cloudy', 'snow', 'clear'];
          const [manualWeather, setManualWeather] = useState(null);
          const effectiveWeatherType = manualWeather || weatherType;

          // When manually cycling weather, also update the game recommendation and weather effects
          const handleCycleWeather = async () => {
            const currentIdx = availableWeatherTypes.indexOf(effectiveWeatherType);
            const nextIdx = (currentIdx + 1) % availableWeatherTypes.length;
            const newWeather = availableWeatherTypes[nextIdx];
            setManualWeather(newWeather);
            setWeatherType(newWeather);
            // Pick a random game for the new weather
            const randomGame = await selectRandomGame(newWeather);
            setGameRecommendation(randomGame);
            setLastGameTitle(randomGame.title);
            // Don't update weather state, just lock manualWeather
          };

          // Tone down sunny text glow (move here to access weatherType)
          useEffect(() => {
            const styleId = 'sunny-headline-style';
            let style = document.getElementById(styleId);
            if (weatherType === 'sunny') {
              if (!style) {
                style = document.createElement('style');
                style.id = styleId;
                style.innerHTML = `
                  .weather-headline-sunny {
                    animation: sunny-glow 3.5s infinite alternate !important;
                    text-shadow: 0 0 2px #ffe9a0, 0 0 1px #fff099 !important;
                  }
                  @keyframes sunny-glow {
                    0% { text-shadow: 0 0 2px #ffe9a0, 0 0 1px #fff099; }
                    100% { text-shadow: 0 0 6px #ffe9a0, 0 0 2px #fff099; }
                  }
                `;
                document.head.appendChild(style);
              }
            } else {
              if (style) style.remove();
            }
          }, [weatherType]);

          // Add crisp border/shadow to main UI cards/buttons for clear weather
          // and softening filter for cloudy weather
          // (inject a class on body based on weatherType)
          useEffect(() => {
            const body = document.body;
            body.classList.remove('clear-ui', 'cloudy-ui');
            if (weatherType === 'clear') {
              body.classList.add('clear-ui');
            } else if (weatherType === 'cloudy') {
              body.classList.add('cloudy-ui');
            }
          }, [weatherType]);

          // Compute weather filter class
          const weatherFilterClass = weatherType === 'clear'
            ? 'clear-weather'
            : weatherType === 'cloudy'
            ? 'cloudy-weather'
            : '';

          const renderLanding = () => {
            return (
              <div className={`min-h-screen relative overflow-hidden ${weatherFilterClass}`}>
                <nav className="flex justify-between items-center px-4 sm:px-8 py-6 relative z-10" style={{backgroundColor: '#504B81'}}>
                  <div 
                    className="text-white text-xl sm:text-2xl font-bold cursor-pointer hover:opacity-80 transition-opacity"
                    onClick={() => setCurrentScreen('landing')}
                  >
                    Sky<span style={{color: '#FFF099'}}>Fable</span>
                  </div>
                  <button
                    onClick={handleCycleWeather}
                    style={navButtonStyle}
                    title="Manually cycle weather for preview"
                  >
                    {!weatherLoaded ? (
                      <span className="flex items-center gap-2">
                        <svg className="animate-spin h-3 w-3" viewBox="0 0 24 24">
                          <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" opacity="0.25"/>
                          <path fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"/>
                        </svg>
                        Loading...
                      </span>
                    ) : (
                      `Weather: ${effectiveWeatherType.charAt(0).toUpperCase() + effectiveWeatherType.slice(1)}`
                    )}
                  </button>
                </nav>

                <div className="flex items-center justify-center min-h-[calc(100vh-120px)] px-4 sm:px-8 transition-all duration-700">
                  <div className="flex flex-col lg:flex-row items-center justify-between max-w-7xl w-full gap-8 lg:gap-0">
                    {/* Left Content */}
                    <div className="flex-1 text-center lg:text-left lg:pr-16">
                      <h1 className="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-bold mb-6 leading-tight" style={{color: '#FFF099'}}>
                        <WeatherHeadline weatherType={effectiveWeatherType}>
                          Find your perfect game based on the weather
                        </WeatherHeadline>
                      </h1>
                      
                      <p className="text-lg sm:text-xl mb-6 text-white opacity-90 font-medium leading-relaxed">
                        Let the weather decide your next gaming adventure
                      </p>
                      
                      <div className="flex items-center justify-center lg:justify-start gap-2 mb-8">
                        <span className="text-white opacity-70 text-sm">How does this work?</span>
                        <div className="relative group">
                          <svg 
                            className="w-4 h-4 text-white opacity-50 cursor-help" 
                            fill="currentColor" 
                            viewBox="0 0 20 20"
                          >
                            <path fillRule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clipRule="evenodd" />
                          </svg>
                          <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none">
                            <div className="bg-gray-900 text-white p-4 rounded-lg shadow-lg text-sm w-72">
                              <div className="font-semibold mb-2">Why weather?</div>
                              <div className="text-gray-200 leading-relaxed">
                                Weather affects our mood and energy levels. Rainy days call for cozy, story-driven games. Sunny weather pairs well with upbeat adventures. We match games to your atmospheric vibe.
                              </div>
                              <div className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900"></div>
                            </div>
                          </div>
                        </div>
                      </div>

                      <button 
                        onClick={handleForecastClick}
                        className="w-full sm:w-auto px-8 py-4 rounded-lg font-bold text-lg transition-all duration-300 hover:scale-105 shadow-lg"
                        style={{
                          backgroundColor: '#FFF099',
                          color: '#504B81'
                        }}
                      >
                        Forecast My Game
                      </button>
                    </div>

                    {/* Right Content - Your Hero Image */}
                    <div className="flex-1 flex justify-center order-first lg:order-last">
                      <SimpleWeatherHero weatherType={effectiveWeatherType} weather={weather} isLoaded={weatherLoaded} />
                    </div>
                  </div>
                </div>
                {/* Fade-in overlay for weather effects */}
                <style>{`
                  #weather-particles-root, #weather-special-root, .weather-overlay-fade {
                    opacity: ${weatherLoaded ? 1 : 0};
                    transition: opacity 0.8s cubic-bezier(.4,0,.2,1);
                  }
                `}</style>
              </div>
            );
          };

          const navButtonStyle = {
            minWidth: '120px',
            padding: '0.5rem 1.5rem',
            fontSize: '1rem',
            borderRadius: '0.5rem',
            border: '1.5px solid #FFF099',
            background: 'transparent',
            color: '#FFF099',
            fontWeight: 600,
            transition: 'all 0.2s',
          };

          const renderLoading = () => {
            // Determine which status to show based on loadingProgress
            const statusIndex = Math.min(
              Math.floor((loadingProgress / 100) * loadingStatuses.length),
              loadingStatuses.length - 1
            );
            const statusMessage = loadingStatuses[statusIndex];
            return (
              <div className={`min-h-screen relative flex flex-col ${weatherFilterClass}`}>
                <nav className="flex justify-between items-center px-8 py-6" style={{backgroundColor: '#504B81'}}>
                  <div 
                    className="text-white text-2xl font-bold cursor-pointer hover:opacity-80 transition-opacity"
                    onClick={() => setCurrentScreen('landing')}
                  >
                    Sky<span style={{color: '#FFF099'}}>Fable</span>
                  </div>
                  <button 
                    style={navButtonStyle}
                  >
                    Forecast My Game
                  </button>
                </nav>

                <div className="flex-1 flex flex-col items-center justify-center px-8">
                  <h1 className="text-5xl md:text-6xl font-bold mb-8 text-white text-center">
                    Sky<span style={{color: '#FFF099'}}>Fable</span>
                  </h1>
                  
                  <p className="text-2xl mb-8 text-center font-medium pulse-animation" style={{color: '#FFF099'}}>
                    {statusMessage}
                  </p>

                  <div className="mb-8">
                    {/* Minimal SVG spinner */}
                    <svg width="96" height="96" viewBox="0 0 96 96" fill="none" xmlns="http://www.w3.org/2000/svg" className="animate-spin" style={{display: 'block'}}>
                      <circle cx="48" cy="48" r="40" stroke="#504B81" strokeWidth="8" opacity="0.15" />
                      <path d="M88 48a40 40 0 1 1-40-40" stroke="#FFF099" strokeWidth="8" strokeLinecap="round" />
                    </svg>
                  </div>
                </div>
              </div>
            );
          };

          const renderResult = () => {
            const getWeatherIcon = (weatherType) => {
              const icons = {
                rain: '🌧️',
                snow: '❄️',
                sunny: '☀️',
                cloudy: '☁️',
                clear: '✨',
                fog: '🌫️'
              };
              return icons[weatherType] || '🌤️';
            };
            const getWeatherExplanation = (weatherType, gameTitle) => {
              const explanations = {
                rain: `${gameTitle || 'This game'}'s cozy, introspective atmosphere perfectly matches the contemplative mood that rainy weather brings.`,
                snow: `The winter themes and survival elements in ${gameTitle || 'this game'} complement the cold, challenging feeling of snowy weather.`,
                sunny: `${gameTitle || 'This game'}'s bright, energetic gameplay matches the uplifting and motivating energy of sunny weather.`,
                cloudy: `The mysterious and atmospheric elements of ${gameTitle || 'this game'} align beautifully with the contemplative uncertainty of cloudy skies.`,
                clear: `${gameTitle || 'This game'}'s transcendent and beautiful experience captures the sense of possibility that comes with perfect clear weather.`,
                fog: `The atmospheric and exploratory nature of ${gameTitle || 'this game'} perfectly matches the mysterious mood of foggy weather.`
              };
              return explanations[weatherType] || `${gameTitle || 'This game'} offers the perfect gaming experience for your current weather mood.`;
            };
            return (
              <div className={`min-h-screen relative overflow-hidden ${weatherFilterClass}`}>
                <nav className="flex justify-between items-center px-8 py-6 relative z-10" style={{backgroundColor: '#504B81'}}>
                  <div 
                    className="text-white text-2xl font-bold cursor-pointer hover:opacity-80 transition-opacity"
                    onClick={() => setCurrentScreen('landing')}
                  >
                    Sky<span style={{color: '#FFF099'}}>Fable</span>
                  </div>
                  <button 
                    onClick={() => setCurrentScreen('landing')}
                    style={navButtonStyle}
                  >
                    New Forecast
                  </button>
                </nav>
                <div className="flex items-center justify-center min-h-[calc(100vh-120px)] px-4 sm:px-8 py-8">
                  <div className="max-w-6xl w-full">
                    {/* Enchanted Game Card */}
                    <div 
                      className="relative rounded-3xl overflow-hidden shadow-2xl backdrop-blur-md transition-all duration-500 hover:scale-[1.02] hover:shadow-3xl"
                      style={{
                        background: weatherType === 'rain' 
                          ? 'linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(59, 130, 246, 0.1) 50%, rgba(147, 197, 253, 0.05) 100%)'
                          : weatherType === 'snow'
                          ? 'linear-gradient(135deg, rgba(219, 234, 254, 0.2) 0%, rgba(191, 219, 254, 0.15) 50%, rgba(147, 197, 253, 0.1) 100%)'
                          : weatherType === 'sunny'
                          ? 'linear-gradient(135deg, rgba(251, 191, 36, 0.15) 0%, rgba(245, 158, 11, 0.1) 50%, rgba(217, 119, 6, 0.05) 100%)'
                          : weatherType === 'cloudy'
                          ? 'linear-gradient(135deg, rgba(107, 114, 128, 0.07) 0%, rgba(75, 85, 99, 0.05) 50%, rgba(55, 65, 81, 0.03) 100%)'
                          : 'linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(124, 58, 237, 0.1) 50%, rgba(109, 40, 217, 0.05) 100%)',
                        border: weatherType === 'clear' ? '2px solid rgba(234, 246, 255, 0.3)' : '1px solid rgba(255, 255, 255, 0.1)',
                        boxShadow: weatherType === 'clear' 
                          ? '0 0 40px rgba(234, 246, 255, 0.2), 0 20px 60px rgba(0, 0, 0, 0.3)'
                          : '0 20px 60px rgba(0, 0, 0, 0.3)',
                        fontFamily: "'Quicksand', sans-serif"
                      }}
                    >
                      <div className="flex flex-col lg:flex-row">
                        {/* Large Game Image - Header Optimized */}
                        <div className="w-full lg:w-3/5 aspect-[616/353] relative overflow-hidden rounded-t-3xl lg:rounded-l-3xl lg:rounded-tr-none lg:rounded-br-none">
                          <img 
                            src={getOptimizedGameImage(gameRecommendation)}
                            alt={gameRecommendation?.title || "Game cover"}
                            className="absolute inset-0 w-full h-full object-cover transition-all duration-700 group-hover:scale-105 group-hover:brightness-110"
                            style={{
                              display: 'block'
                            }}
                            onError={(e) => {
                              console.log('Optimized header image failed, trying alternatives...');
                              const steamId = extractSteamAppId(gameRecommendation?.steamUrl);
                              // First fallback: try standard header (460x215 - guaranteed to show proper content)
                              if (!e.target.dataset.triedHeader && steamId) {
                                e.target.src = `https://cdn.akamai.steamstatic.com/steam/apps/${steamId}/header.jpg`;
                                e.target.dataset.triedHeader = 'true';
                                return;
                              }
                              // Second fallback: try original gameImage from JSON
                              if (!e.target.dataset.triedOriginal && gameRecommendation?.gameImage) {
                                e.target.src = gameRecommendation.gameImage;
                                e.target.dataset.triedOriginal = 'true';
                                return;
                              }
                              // Third fallback: try local placeholder
                              if (!e.target.dataset.triedPlaceholder) {
                                e.target.src = './images/placeholder.png';
                                e.target.dataset.triedPlaceholder = 'true';
                                return;
                              }
                              // Final fallback: show styled placeholder
                              e.target.style.display = 'none';
                              e.target.parentNode.style.background = 'linear-gradient(135deg, #F59E0B 0%, #D97706 50%, #B45309 100%)';
                              e.target.parentNode.innerHTML = `
                                <div class=\"absolute inset-0 flex flex-col items-center justify-center text-center p-8\" style=\"font-family: 'Quicksand', sans-serif;\">
                                  <div class=\"text-6xl mb-6\">🎮</div>
                                  <h3 class=\"text-2xl font-bold text-white mb-4 tracking-wide\">
                                    ${(gameRecommendation?.title || 'GAME').toUpperCase()}
                                  </h3>
                                  <div class=\"text-orange-100 font-medium\">
                                    Image unavailable
                                  </div>
                                </div>
                              `;
                            }}
                            onLoad={() => {
                              console.log('Header-optimized image loaded:', gameRecommendation?.title);
                            }}
                          />
                          {/* Weather Overlay Effect */}
                          <div 
                            className="absolute inset-0 pointer-events-none transition-opacity duration-700 group-hover:opacity-75"
                            style={{
                              background: weatherType === 'rain' 
                                ? 'linear-gradient(45deg, transparent 0%, rgba(59, 130, 246, 0.1) 100%)'
                                : weatherType === 'snow'
                                ? 'linear-gradient(45deg, transparent 0%, rgba(219, 234, 254, 0.15) 100%)'
                                : weatherType === 'sunny'
                                ? 'linear-gradient(45deg, transparent 0%, rgba(251, 191, 36, 0.1) 100%)'
                                : 'transparent',
                              opacity: 0.6
                            }}
                          />
                        </div>
                        {/* Game Information */}
                        <div className="lg:w-2/5 p-6 sm:p-8 flex flex-col justify-between">
                          {/* Weather Info Badge */}
                          <div className="flex items-center gap-2 mb-4 text-white text-sm opacity-80">
                            <span className="text-lg">{getWeatherIcon(effectiveWeatherType)}</span>
                            <span>{weather?.name || 'Your Location'} • {weather?.main?.temp || 20}°C</span>
                          </div>
                          {/* Tags */}
                          <div className="flex flex-wrap gap-2 mb-4">
                            {(gameRecommendation?.tags || ['Single-player', 'Atmospheric', 'Story-Rich']).slice(0, 3).map((tag, index) => (
                              <span 
                                key={index}
                                className="px-3 py-1 rounded-full text-xs font-semibold backdrop-blur-sm"
                                style={{
                                  backgroundColor: 'rgba(255, 248, 204, 0.2)',
                                  color: '#FFF099',
                                  border: '1px solid rgba(255, 248, 204, 0.3)'
                                }}
                              >
                                {tag}
                              </span>
                            ))}
                          </div>
                          {/* Game Title */}
                          <h2 className="text-2xl sm:text-3xl lg:text-4xl font-bold mb-4 leading-tight" style={{color: '#FFF099'}}>
                            {gameRecommendation?.title || 'Firewatch'}
                          </h2>
                          {/* Ratings Section */}
                          <div className="flex items-center gap-4 mb-6">
                            {/* Game Rating */}
                            <div className="flex items-center gap-2">
                              <div className="flex items-center gap-1">
                                <span className="text-green-400">🎮</span>
                                <span className="text-white text-sm font-medium">
                                  {gameRecommendation?.rating || 80}/100
                                </span>
                              </div>
                            </div>
                            {/* Weather Score with Enhanced Tooltip */}
                            <div className="relative flex items-center gap-2 group cursor-help">
                              <div className="flex items-center gap-1">
                                <span className="text-blue-400">🌤️</span>
                                <span className="text-white text-sm font-medium">
                                  {gameRecommendation?.weatherScore || 8}/10
                                </span>
                              </div>
                              {/* Compact multi-line tooltip that fits within card */}
                              <div className="opacity-0 group-hover:opacity-100 sf-tooltip"
                                   >
                                <div className="font-semibold mb-2 text-blue-300 text-xs">Weather Match</div>
                                <div className="text-gray-200 leading-relaxed text-xs">
                                  {(() => {
                                    const explanations = {
                                      rain: "Cozy, introspective atmosphere matches rainy day contemplation perfectly.",
                                      snow: "Winter themes and survival elements complement cold, challenging snowy weather.",
                                      sunny: "Bright, energetic gameplay matches the uplifting motivation of sunny weather.",
                                      cloudy: "Mysterious atmosphere aligns with the contemplative uncertainty of cloudy skies.",
                                      clear: "Transcendent experience captures the sense of possibility from perfect clear weather.",
                                      fog: "Atmospheric exploration perfectly matches the mysterious mood of foggy weather."
                                    };
                                    return explanations[effectiveWeatherType] || "Perfect gaming experience for your current weather mood.";
                                  })()}
                                </div>
                                {/* Arrow pointing down and positioned to the right */}
                                <div 
                                  className="absolute border-4 border-transparent border-t-gray-900"
                                  style={{
                                    top: '100%',
                                    right: '12px',
                                    left: 'auto',
                                  }}
                                ></div>
                              </div>
                            </div>
                          </div>
                          {/* Description */}
                          <p className="text-white text-sm sm:text-base leading-relaxed mb-6 opacity-90 font-medium flex-grow">
                            {gameRecommendation?.description || "Today's weather sets the perfect mood for this atmospheric adventure. Immerse yourself in a world that matches your current vibe."}
                          </p>
                          {/* Action Buttons */}
                          <div className="flex flex-col sm:flex-row gap-3">
                            <button 
                              onClick={() => window.open(gameRecommendation?.steamUrl || "https://store.steampowered.com/app/383870/Firewatch/", '_blank')}
                              className="flex-1 px-6 py-3 rounded-lg font-bold transition-all duration-300 hover:scale-105 shadow-lg hover:shadow-xl"
                              style={{backgroundColor: '#FFF099', color: '#504B81'}}
                            >
                              View on Steam
                            </button>
                            <button 
                              onClick={handleRollAgain}
                              className="flex-1 px-6 py-3 border-2 rounded-lg font-bold transition-all duration-300 hover:bg-white hover:bg-opacity-10 hover:scale-105 shadow-lg hover:shadow-xl"
                              style={{borderColor: 'rgba(255, 248, 204, 0.5)', color: '#FFF8CC', backgroundColor: 'transparent'}}
                            >
                              Roll Again
                            </button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            );
          };

          const renderLocationError = () => (
            <div className={`min-h-screen relative flex flex-col ${weatherFilterClass}`}>
              <nav className="flex justify-between items-center px-8 py-6" style={{backgroundColor: '#504B81'}}>
                <div 
                  className="text-white text-2xl font-bold cursor-pointer hover:opacity-80 transition-opacity"
                  onClick={() => setCurrentScreen('landing')}
                >
                  Sky<span style={{color: '#FFF099'}}>Fable</span>
                </div>
                <button 
                  onClick={() => setCurrentScreen('landing')}
                  style={navButtonStyle}
                >
                  Back to Home
                </button>
              </nav>

              <div className="flex-1 flex flex-col items-center justify-center px-8">
                <div className="text-center max-w-md">
                  <div className="text-6xl mb-6">📍</div>
                  <h1 className="text-4xl font-bold text-white mb-6">
                    Location Needed
                  </h1>
                  
                  <p className="text-lg mb-8 text-white opacity-90 font-medium leading-relaxed">
                    SkyFable needs your location to check the weather and find the perfect game for you. 
                    Please enable location permissions and try again.
                  </p>

                  <div className="space-y-4">
                    <button 
                      onClick={handleForecastClick}
                      className="w-full px-8 py-3 rounded-lg font-bold transition-all duration-300 hover:scale-105 shadow-lg"
                      style={{
                        backgroundColor: '#FFF099',
                        color: '#504B81'
                      }}
                    >
                      Try Again
                    </button>
                    
                    <button 
                      onClick={() => setCurrentScreen('landing')}
                      className="w-full px-8 py-3 border-2 rounded-lg font-bold transition-all duration-300"
                      style={{
                        borderColor: '#FFF8CC',
                        color: '#FFF8CC',
                        backgroundColor: 'transparent'
                      }}
                    >
                      Back to Home
                    </button>
                  </div>

                  <p className="text-sm text-white opacity-60 mt-6">
                    💡 Tip: Look for the location icon in your browser's address bar
                  </p>
                </div>
              </div>
            </div>
          );

          switch (currentScreen) {
            case 'loading':
              return renderLoading();
            case 'result':
              return renderResult();
            case 'location-error':
              return renderLocationError();
            default:
              return renderLanding();
          }
        };

        const SimpleWeatherHero = ({ weatherType, weather, isLoaded }) => {
          if (!isLoaded) {
            return React.createElement('div', {
              className: "h-full flex flex-col items-center justify-center text-center p-8 bg-gradient-to-br from-purple-900/20 to-blue-900/20 rounded-lg backdrop-blur-sm"
            },
              React.createElement('div', { className: "text-6xl mb-4 animate-pulse" }, '🌤️'),
              React.createElement('div', { className: "text-white text-lg font-medium" }, 'Detecting weather...'),
              React.createElement('div', { className: "text-white opacity-70 text-sm mt-2" }, 'Finding your perfect atmospheric match')
            );
          }

          const weatherStyles = {
            rain: {
              gradient: 'from-indigo-700/30 via-blue-800/20 to-indigo-900/30',
              accent: 'text-blue-200',
              icon: '🌧️',
              mood: 'Cozy Gaming'
            },
            sunny: {
              gradient: 'from-yellow-300/20 via-yellow-500/15 to-orange-400/25',
              accent: 'text-yellow-200',
              icon: '☀️',
              mood: 'Energetic Adventures'
            },
            snow: {
              gradient: 'from-blue-200/25 via-white/10 to-indigo-200/20',
              accent: 'text-blue-100',
              icon: '❄️',
              mood: 'Survival Challenges'
            },
            cloudy: {
              gradient: 'from-gray-400/25 via-indigo-500/15 to-gray-700/20',
              accent: 'text-gray-200',
              icon: '☁️',
              mood: 'Mysterious Journeys'
            },
            clear: {
              gradient: 'from-purple-400/20 via-indigo-500/15 to-purple-700/25',
              accent: 'text-purple-200',
              icon: '✨',
              mood: 'Transcendent Experiences'
            }
          };

          const style = weatherStyles[weatherType] || weatherStyles.clear;

          return React.createElement('div', {
            className: `h-full relative rounded-lg bg-gradient-to-br ${style.gradient} backdrop-blur-sm border border-white/10 overflow-hidden`
          },
            // Subtle animated background
            React.createElement('div', { className: "absolute inset-0 opacity-10" },
              React.createElement('div', { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/5 to-transparent transform skew-x-12 animate-pulse" })
            ),
            
            // Main content
            React.createElement('div', { className: "relative h-full flex flex-col justify-center items-center p-8 text-center" },
              
              // Large weather icon
              React.createElement('div', { 
                className: "text-8xl mb-6 filter drop-shadow-lg",
                style: { animation: 'bounce-slow 3s ease-in-out infinite' }
              }, style.icon),
              
              // Weather info
              React.createElement('div', { className: "space-y-3" },
                React.createElement('div', { className: `text-2xl font-bold ${style.accent} filter drop-shadow-md` },
                  weather?.name || 'Your Location'
                ),
                React.createElement('div', { className: "text-white text-lg font-semibold capitalize" },
                  weather?.weather?.[0]?.description || weatherType
                ),
                weather?.main?.temp && React.createElement('div', { className: "text-white/80 text-xl font-medium" },
                  `${Math.round(weather.main.temp)}°C`
                )
              ),
              
              // Gaming mood
              React.createElement('div', { className: "mt-8 p-4 bg-black/30 rounded-lg backdrop-blur border border-white/20" },
                React.createElement('div', { className: "text-white/90 text-sm font-medium mb-1" }, 'Perfect Weather For'),
                React.createElement('div', { className: `text-lg font-bold ${style.accent}` }, style.mood)
              )
            )
          );
        };

        ReactDOM.render(React.createElement(SkyFable), document.getElementById('root'));
    </script>
    <a href='https://ko-fi.com/H2H21HEPVU' target='_blank' id="kofi-float-btn">
      <img height='36' style='border:0px;height:36px;' src='https://storage.ko-fi.com/cdn/kofi5.png?v=6' border='0' alt='Buy Me a Coffee at ko-fi.com' />
    </a>
</body>
</html>
